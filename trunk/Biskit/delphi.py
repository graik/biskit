##
## Biskit, a toolkit for the manipulation of macromolecular structures
## Copyright (C) 2004-2011 Raik Gruenberg
##
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 3 of the
## License, or any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
## General Public License for more details.
##
## You find a copy of the GNU General Public License in the file
## license.txt along with this program; if not, write to the Free
## Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

## last $Author: graik $
## last $Date: 2009-05-09 14:17:28 +0200 (Sat, 09 May 2009) $
## $Revision: $
"""
Wrapper for Delphi -- PB electrostatic potential calculation.

Application: 
"""

import tempfile, os
import numpy as N

from Biskit import Executor, PDBModel, Reduce
from Biskit import AmberPrepParser
import Biskit.tools as T
import Biskit.mathUtils as U

class DelphiError( Exception ):
    pass

class DelphiCharges( object ):
    """
    Helper class to write out a (custom) Delphi charge file
    """
    
    def __init__(self, restypes={} ):
        """
        @param fname: output file name
        @type  fname: str
        @param restypes: dict of Residue type definitions indexed by code
        @type  restypes: { str: AmberResidueType }
        """
        self.restypes = restypes
    
    def res2delphi(self, restype, resnumber=None, comment='' ):
        """
        Generate the Delphi charge record for a single residue (residue type).
        @type restype: AmberResidueType
        @param resnumber: residue number to use in the Delphi record
        @type  resnumber: int
        @return: several lines formatted as in Delphi charge files
        @rtype: str
        """
        resnumber = resnumber or ''

        r = ''
        for atom in restype.atoms.iterDicts():
 
            atom['resnumber'] = str(resnumber)
            atom['rescode'] = restype.code
            r += '%(name)-5s %(rescode)3s %(resnumber)-5s %(charge)6.3f'%\
                 atom

            if comment:
                r += '  ! %s' % comment
                comment = ''  # only print once
            r += '\n'
        return r
    
    def tofile( self, fname ):
        fname = T.absfile( fname )
        f = open( fname, 'w' )
        f.write('! charge file generated by Biskit.delphi.DelphiCharges\n')
        f.write('atom__resnumbc_charge_\n')
        try:
            for res in self.restypes:
                f.write( self.res2delphi( res ) )
        finally:
            f.close()
        
    
    def checkmodel( self, m ):
        """
        Verify that all residues and atoms in model m are covered by charges.
        @type m: PDBModel
        @return: residues not described or with missing atoms, atom names
        @rtype: ([int], [str])
        """
        assert( isinstance(m,PDBModel) )
        missing = {}

        for i, resm in enumerate( m.resModels() ):
            
            resname = resm['residue_name'][0]
            missing_atm = []
            missing_res = not resname in self.restypes
            
            if not missing_res:
                resatoms = resm.atomNames()
                standard = self.restypes[resname].atomNames()
                missing_atm = U.difference( resatoms, standard )
            
            if missing_res or missing_atm:
                missing[i] = missing_atm
        
        return missing
    
    def atomkey( self, residue ):
        """
        Create a string key encoding the atom content of residue.
        @param residue: model or AmberResidue
        @type  residue: PDBModel or AmberResidue
        @return: key formed from alphabetically sorted atom content of residue
        @rtype: str
        """
        r = residue.atomNames()
        r.sort()
        r = ''.join( r )
        return r
        
    
    def resindex( self, *resdics):
        """
        Build an index of residue types indexed by ordered atom content.
        @param *resdics: additional restype dictionaries indexed by res. name
        @type  *resdics: {str_resname: AmberResidue}
        @return: dict with alphabetically ordered atom content as key
        @rtype : { str_atoms : AmberResidue }
        """
        r = {}
        ## default residues treated last to give them priority
        resdics = resdics + ( self.restypes, )  

        for rdic in resdics:
            for resname, restype in rdic.items():
                r[ self.atomkey(restype) ] = restype

        return r
    
    def customCharges( self, model, comment='' ):
        """
        @param model: structure for which Delphi charge file should be created
        @type  model: PDBModel
        @return: Delphi charge table, list of non-matching residues
        @rtype: str
        """
        index = self.resindex()
        missing = []
        r = ''
        
        for res in model.resModels():
            rtype = index.get( self.atomkey( res ), None)
            resnumber = res['residue_number'][0]

            if rtype is not None:
                
                rtype.code = res['residue_name'][0]
                    
                r += self.res2delphi( rtype, resnumber=resnumber, 
                                      comment=comment )
                comment = ''  ## erase comment
            else:
                missing += [ res ]
    
        return r, missing
        
   
    
class Delphi( Executor ):
    """
    Calculate electrostatic potentials and potential maps with Delphi.
    [Work in Progress]
    
    The current workflow of this wrapper is:
    1. take input model/structure, remove hydrogens
    2. add and optimize hydrogens with the reduce program
    3. adapt residue and atom names to Amber conventions
    4. match each residue (by atom content) to a residue from a list of 
       Amber residue topology files
    5. Create custom delphi charge file with Amber partial charges
    6. Run Delphi in temporary folder 
    7. not yet implemented: parse results
    
    
    Usage
    =====

    >>> D = Delphi( inputmodel )
    >>> result = D.run()
    
    Customization
    =============
    
    The default delphi parameter file can be replaced (parameter template).
    Note though that you should keep the place holders for input and output
    files. The default parameter file is taken from:

        Biskit/data/delphi/delphi_simple.prm
    
    The default handling and matching of partial charges can be modified by:
    
        * providing a ready-made Delphi charge file (parameter f_charges)
        * providing an alternative list of Amber topology files from which 
          residues are looked up by their atom content (parameter topologies)

    @note: Command configuration: biskit/Biskit/data/defaults/exe_delphi.dat
    """

    F_RADII = 'default.siz'           ## default Delphi atom radius file
    F_CHARGES = 'prot_amb.crg'        ## default all-purpose charge-file
    F_PARAMS = 'delphi_simple.prm'    ## default delphi parameter file
    
    ## list of Amber topology files in decending priority
    ## will be mined for matching residues to assign charges
    F_RESTYPES = ['all_amino03.in',
                  'all_aminoct03.in',
                  'all_aminont03.in',
                  'all_nuc02.in' ]
    
    
    def __init__( self, model, template=None, topologies=None,
                  f_charges=None,
                  **kw ):
        """
        @param model: structure for which potential should be calculated
        @type  model: PDBModel
        @param template: delphi command file template [None=use default]
        @type  template: str
        @param f_radii: alternative delphi atom radii file [None=use default]
        @type  f_radii: str
        @param topologies: alternative list of residue charge/topology files
                           [default: amber/residues/all*]
        @type  topologies: [ str ]
        @param f_charges: alternative delphi charge file 
                          [default: create custom]
        @type  f_charges: str

        @param kw: additional key=value parameters for Executor:
        @type  kw: key=value pairs
        ::
          debug    - 0|1, keep all temporary files (default: 0)
          verbose  - 0|1, print progress messages to log (log != STDOUT)
          node     - str, host for calculation (None->local) NOT TESTED
                          (default: None)
          nice     - int, nice level (default: 0)
          log      - Biskit.LogFile, program log (None->STOUT) (default: None)
        """
        template = template or T.dataRoot() + '/delphi/' + self.F_PARAMS
        
        tempdir = self.newtempfolder( tempdir=True )  ## create new temp folder
        f_in = tempfile.mktemp( '.inp', 'delphi_', dir=tempdir )
        
        self.f_pdb = tempfile.mktemp( '.pdb', 'delphi_', dir=tempdir)
        self.f_grid = tempfile.mktemp( '_grid.phi', 'delphi_', dir=tempdir )
        self.f_map = None
        self.f_radii = None
        self.topologies = topologies or self.F_RESTYPES
        self.f_charges = f_charges or tempfile.mktemp( '.crg', 'delphi_',
                                                       dir=tempdir )
        
        Executor.__init__( self, 'delphi', 
                           template=template,
                           f_in=f_in,
                           args=f_in,
                           catch_err=True,
                           tempdir=tempdir,
                           cwd=tempdir,
                           **kw )
        
        self.model = model
        self.delphimodel = None

        
    def version(self):
        return 'Delphi $Revision: $'


    def __prepareFolder( self ):
        """
        Link default parameter files into working directory.
        """
        try:
            f_radii = self.f_radii or T.dataRoot() + '/delphi/' + self.F_RADII

            target = os.path.join(self.cwd, 'radii.siz')
            if not os.path.exists( target ):
                os.symlink( f_radii, target )

        except OSError, error:
            raise DelphiError, \
                  'Error preparing temporary folder for Delphi\n'+\
                  'Error: %r\n' % error +\
                  'folder: %r\n' % self.cwd
        

    def __prepareCharges(self, f_out ):

        unhandled = self.delphimodel
        
        try:
            f = open( f_out, 'w' )
            f.write('! custom charge file generated by Biskit.delphi.Delphi\n')
            f.write('atom__resnumbc_charge_\n')
            
            for topo in self.topologies:
                if unhandled:
                    dc = DelphiCharges( AmberPrepParser(topo).residueDict() )

                    r, missing = dc.customCharges( unhandled, 
                                                   comment= 'from %s:'% topo)
                    f.write( r )
                    
                    if missing: ## create new model with only unhandled residues
                        unhandled = missing[0].concat( *missing[1:] )
                    else:
                        unhandled = None
            
            f.close()
          
        except IOError, why: 
            raise IOError, 'Error creating custom delphi charge file '+f_out+\
                  '( '+str(why)+' )'
        

    
    def prepare( self ):
        """
        Overrides Executor method.
        """
        Executor.prepare( self )
        
        self.__prepareFolder()
        
        reducer = Reduce( self.model, verbose=self.verbose,
                          tempdir=self.tempdir, cwd=self.cwd,
                          log=self.log, debug=self.debug )
        if self.verbose: 
            self.log.add('adding hydrogen atoms to input structure')

        self.delphimodel = reducer.run()
        self.delphimodel.xplor2amber()
        self.delphimodel.writePdb( self.f_pdb )
        
        if not os.path.exists( self.f_charges ):
            self.__prepareCharges( self.f_charges )
        

    def cleanup( self ):
        """
        Tidy up the mess you created.
        """        
        if not self.debug:
            T.tryRemove( self.f_pdb )

        Executor.cleanup( self )

    def isFailed( self ):
        """
        Overrides Executor method
        """
        return False

    def fail( self ):
        """
        Overrides Executor method. Called when execution fails.
        """
        s = 'Delphi failed. Please check the program output in the '+\
          'field `output` of this Delphi instance (e.g. `print x.output`)!'
        self.log.add( s )

        raise DelphiError, s

    def parseOutput( self, fname ):
        """
        """
        pass
    
    def finish( self ):
        """
        Overrides Executor method
        """
        Executor.finish( self )
        try:
            f = open( self.f_out, 'r')
            self.output = f.read()
            f.close()
        except IOError, why:
            raise DelphiError, 'Cannot open delphi output file %s' % self.f_out
            


#############
##  TESTING        
#############
import Biskit.test as BT

class Test(BT.BiskitTest):
    """Test class"""

    TAGS = [ BT.EXE ]
    MODEL= None

    def test_delphi( self ):
        """Delphi test"""
        if self.local: print 'Loading PDB...'

        self.m1 = self.MODEL or \
            PDBModel( T.testRoot( 'lig/1A19_dry.model' ) )
        Test.MODEL = self.m1


        if self.local: print 'Starting Delphi'
        self.x = Delphi( self.m1, debug=self.DEBUG,
                         verbose=self.local )

        if self.local:
            print 'Running'

        self.r = self.x.run()

        if self.local:
            print "Result: "
            print self.r

            
    def test_delphiCharges( self ):
        """DelphiCharges test"""
        resnormal = AmberPrepParser( 'all_amino03.in' ).residueDict()
        resnterm  = AmberPrepParser( 'all_aminont03.in').residueDict()
        rescterm  = AmberPrepParser( 'all_aminoct03.in').residueDict()
        
        if self.local:
            T.errWrite( 'loading PDB...' )

        self.m1 = self.MODEL or PDBModel( T.testRoot( 'lig/1A19_dry.model' ) )
        Test.MODEL = self.m1
        if self.local:
            T.errWriteln( 'Done.' )
        
        if self.local:
            T.errWrite( 'Adding hydrogens to model (reduce)...' )

        self.rmodel = Reduce( self.m1 ).run()
        self.rmodel.xplor2amber()
        if self.local:
            T.errWriteln( 'Done.' )
        
        self.dc = DelphiCharges( resnormal )
        if self.local:
            print
            print self.dc.res2delphi( self.dc.restypes['CYS'] )

        missing = self.dc.checkmodel( self.rmodel )
        if self.local:
            print 'atom types identified as missing: ', missing
        
        self.assert_( 0 in missing.keys(), 'residue missmatch (0)' )
        self.assert_( 88 in missing.keys(), 'residue missmatch (88)' )
        self.assert_( U.difference(['H1', 'H2', 'H3'], missing[0]) == [],
                      'atom missmatch (0)' )
        self.assert_( 'OXT' in missing[88], 'atom missmatch (88)' )
        
        self.customCharges = self.dc.customCharges( self.rmodel )
        
        

if __name__ == '__main__':

    BT.localTest(debug=True)
    
