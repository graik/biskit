## produced with:
## grep "oldN\." **/*.py | grep -v "##" | grep -v '@' | grep -v stats.py \
## | grep -v pstat.py > __listoldnumeric_uses.txt


Biskit/AmberCrdParser.py:        return oldN.reshape( xyz, ( len(xyz) / 3, 3 ) ).astype(oldN.Float32)
Biskit/AmberCrdParser.py:        t.frames = oldN.array( xyz ).astype(oldN.Float32)
Biskit/AmberEntropist.py:                if not mask is None:   mask = oldN.take( mask, i )
Biskit/AmberEntropist.py:            m.keep( oldN.nonzero( m.maskProtein() ) )
Biskit/AmberEntropist.py:            m.keep( oldN.nonzero( m.maskHeavy() ) )
Biskit/AmberEntropist.py:            traj.removeAtoms( oldN.nonzero( oldN.logical_not( aMask ) )  )
Biskit/AmberEntropist.py:            traj = traj.compressAtoms( oldN.logical_not(traj.ref.maskSolvent()) )
Biskit/AmberEntropist.py:        pw = oldN.zeros( (len(all), len(all)), oldN.Float32 )
Biskit/AmberEntropist.py:            overlap = oldN.sum( oldN.array( [ pw[ i ] for i in r ] ) )
Biskit/AmberEntropist.py:            pos = oldN.argmin( overlap )
Biskit/AmberEntropist.py:        return oldN.take( all, r )
Biskit/AmberEntropyMaster.py:            return oldN.arange( *v )
Biskit/AmberEntropyMaster.py:        outliers = oldN.nonzero( traj.outliers( z=self.zfilter,
Biskit/AmberParmBuilder.py:        pw = oldN.less( pw, cutoff )
Biskit/AmberParmBuilder.py:        center = oldN.average( model.getXyz() )
Biskit/AmberParmBuilder.py:                capN = MU.union( capN, oldN.array( end_broken ) + 1 )
Biskit/AmberParmBuilder.py:        mask = oldN.zeros( len( model ),oldN.Int )
Biskit/AmberParmBuilder.py:        oldN.put( mask, i_atoms, 1 )
Biskit/AmberParmBuilder.py:        return oldN.nonzero( oldN.logical_not( mask ) )
Biskit/AmberParmBuilder.py:        eq = oldN.array( self.m1.xyz == self.m2.xyz )
Biskit/AmberRstParser.py:        return oldN.reshape(self.xyz, ( self.n, 3 ) ).astype(oldN.Float32)
Biskit/AmberRstParser.py:        for x in oldN.ravel( self.xyz )[:10]:
Biskit/AmberRstParser.py:        for x in oldN.ravel( self.xyz ):
Biskit/AmberRstParser.py:        self.assertEqual( oldN.shape(self.xyz), (11200,3) )
Biskit/BisList.py:        return self.take( oldN.nonzero( mask ), deepcopy=deepcopy )
Biskit/BisList.py:        maskL = oldN.greater_equal( vLst, vLow )
Biskit/BisList.py:        maskH = oldN.less_equal( vLst, vHigh )
Biskit/BisList.py:        return oldN.nonzero( maskL * maskH )
Biskit/BisList.py:        return oldN.nonzero( mask )
Biskit/BisList.py:        return oldN.nonzero( mask )
Biskit/BisList.py:        return oldN.argmax( vLst )
Biskit/BisList.py:        return oldN.argmin( vLst )
Biskit/ChainSeparator.py:        matrix = 1.0 * oldN.zeros((chainCount,chainCount))
Biskit/ChainSeparator.py:                self.chains = oldN.compress(chainMask, self.chains)
Biskit/ChainSeparator.py:                diag = oldN.diagonal(matrix, offset ,0,1)
Biskit/ChainSeparator.py:                avg = 1.0 * oldN.sum(diag)/len(diag)
Biskit/ColorSpectrum.py:        s = oldN.shape( a )
Biskit/ColorSpectrum.py:        v = oldN.ravel( a )
Biskit/ColorSpectrum.py:        r = oldN.reshape( r, s )
Biskit/ColorSpectrum.py:    r = 1. * oldN.arange( 0, nColors ) / nColors
Biskit/Dock/Analyzer.py:        #self.t_rec.removeAtoms( oldN.logical_not( m_t_rec ) )
Biskit/Dock/Analyzer.py:        #self.t_lig.removeAtoms( oldN.logical_not( m_t_lig ) )
Biskit/Dock/Analyzer.py:        #bnd_rec.remove( oldN.logical_not( m_bnd_rec ) )
Biskit/Dock/Analyzer.py:        #bnd_lig.remove( oldN.logical_not( m_bnd_lig ) )
Biskit/Dock/Analyzer.py:        result = [ oldN.sum( oldN.greater( o, cutoff ) ) for o in result ]
Biskit/Dock/Analyzer.py:        a,b = oldN.shape( contMat )
Biskit/Dock/Analyzer.py:        nContacts = oldN.sum( oldN.sum( contMat ))
Biskit/Dock/Analyzer.py:            r_size, l_size = oldN.shape( contMat )
Biskit/Dock/Analyzer.py:            maskLig = oldN.ones( l_size )
Biskit/Dock/Analyzer.py:            maskRec = oldN.ones( r_size )
Biskit/Dock/Analyzer.py:        c_mask = oldN.ravel( oldN.outerproduct( maskRec, maskLig ) )
Biskit/Dock/Analyzer.py:        c_pos = oldN.nonzero( c_mask )
Biskit/Dock/Analyzer.py:        cont = oldN.take( oldN.ravel(contMat), c_pos )
Biskit/Dock/Analyzer.py:            r = oldN.zeros(a*b)
Biskit/Dock/Analyzer.py:            oldN.put( r, c_pos, ranCont)
Biskit/Dock/Analyzer.py:            result += [ oldN.reshape( r, (a,b) ) ]
Biskit/Dock/Analyzer.py:        return oldN.take( lst, pos )
Biskit/Dock/Analyzer.py:            mask = oldN.ones( len(lst)  )
Biskit/Dock/Analyzer.py:            lst = oldN.array( lst )
Biskit/Dock/Analyzer.py:        pos = oldN.nonzero( mask )
Biskit/Dock/Analyzer.py:        rand_pos = oldN.array( [ self.__shuffleList( pos ) for i in range(n) ] )
Biskit/Dock/Analyzer.py:            oldN.put( r, p, oldN.take( lst, pos ) )
Biskit/Dock/Analyzer.py:        self.assertEqual( oldN.shape(rand_mat[1]), (1075, 876) ) 
Biskit/Dock/ComplexEvolvingList.py:            l = oldN.take( l, indices )
Biskit/Dock/ComplexList.py:            l = oldN.take( oldN.array(l,'O'), indices )
Biskit/Dock/ComplexList.py:        maskL = oldN.greater_equal( vLst, vLow )
Biskit/Dock/ComplexList.py:        maskH = oldN.less_equal( vLst, vHigh )
Biskit/Dock/ComplexList.py:        return oldN.nonzero( maskL * maskH )
Biskit/Dock/ComplexList.py:        return oldN.nonzero( mask )
Biskit/Dock/ComplexList.py:        return oldN.nonzero( mask )
Biskit/Dock/ComplexList.py:        return oldN.argmax( vLst )
Biskit/Dock/ComplexList.py:        return oldN.argmin( vLst )
Biskit/Dock/Complex.py:            self.ligandMatrix = oldN.array([ [1,  0,  0, 0],
Biskit/Dock/Complex.py:                                        [0,  0,  0, 1],], oldN.Float32)
Biskit/Dock/Complex.py:        self.ligandMatrix = oldN.array( self.ligandMatrix,oldN.Float32 )
Biskit/Dock/Complex.py:               len(oldN.shape( self.contacts['result'] ) )==2:
Biskit/Dock/Complex.py:            self.contacts['shape'] = oldN.shape( m )
Biskit/Dock/Complex.py:            self.contacts['result'] = oldN.nonzero( oldN.ravel( m ) ).astype(oldN.Int32)
Biskit/Dock/Complex.py:        equal = oldN.logical_and(self.resContacts( cutoff=cutoff ),
Biskit/Dock/Complex.py:        total = oldN.logical_or( self.resContacts(cutoff),
Biskit/Dock/Complex.py:        return oldN.sum(oldN.sum( equal )) * 1.0 / oldN.sum(oldN.sum( total ))
Biskit/Dock/Complex.py:                   abs( oldN.sum( oldN.sum( contactMatrix_a - contactMatrix_b )))
Biskit/Dock/Complex.py:        equality = oldN.logical_and(self.resContacts( cutoff=cutoff ),
Biskit/Dock/Complex.py:        return abs(oldN.sum(oldN.sum( equality )))
Biskit/Dock/Complex.py:        both = oldN.logical_or( self.resContacts(cutoff), ref.resContacts(cutoff))
Biskit/Dock/Complex.py:        return oldN.sum(oldN.sum(both)) - self.contactsShared( ref, cutoff )
Biskit/Dock/Complex.py:        result = oldN.sum(oldN.sum( ref_cont * cont ))*1.0
Biskit/Dock/Complex.py:        return result / oldN.sum( oldN.sum( ref_cont ))
Biskit/Dock/Complex.py:        lig, ligRef = oldN.clip( oldN.sum(cont),0,1),  oldN.clip( oldN.sum(contRef), 0,1)
Biskit/Dock/Complex.py:        rec    = oldN.clip( oldN.sum(cont, 1),0,1)
Biskit/Dock/Complex.py:        recRef = oldN.clip( oldN.sum(contRef, 1), 0,1)
Biskit/Dock/Complex.py:        fLig = oldN.sum( oldN.logical_and( lig, ligRef )) *1./ oldN.sum( ligRef )
Biskit/Dock/Complex.py:        fRec = oldN.sum( oldN.logical_and( rec, recRef )) *1./ oldN.sum( recRef )
Biskit/Dock/Complex.py:        if_rec = ref.rec_model.res2atomMask( oldN.sum( contacts, 1 ) )
Biskit/Dock/Complex.py:        if_lig = ref.lig_model.res2atomMask( oldN.sum( contacts, 0 ) )
Biskit/Dock/Complex.py:        mask_interface = oldN.concatenate( (if_rec, if_lig) )
Biskit/Dock/Complex.py:        mask_heavy = oldN.concatenate( (ref.rec().maskHeavy(),
Biskit/Dock/Complex.py:        maskLig = oldN.sum( cm )
Biskit/Dock/Complex.py:        maskRec = oldN.sum( oldN.transpose( cm ))
Biskit/Dock/Complex.py:        seqLig = oldN.compress( maskLig, self.lig().sequence() )
Biskit/Dock/Complex.py:        seqRec = oldN.compress( maskRec, self.rec().sequence() )
Biskit/Dock/Complex.py:        s = oldN.sum( result.values() )
Biskit/Dock/Complex.py:           len( oldN.shape( self.contacts['result'])) == 1:
Biskit/Dock/Complex.py:            m = oldN.zeros( lenRec * lenLig )
Biskit/Dock/Complex.py:            oldN.put( m, self.contacts['result'], 1 )
Biskit/Dock/Complex.py:            self.contacts['result'] = oldN.reshape( m, (lenRec, lenLig) )
Biskit/Dock/Complex.py:            cm = oldN.transpose( cm )
Biskit/Dock/Complex.py:                cm = oldN.concatenate( ( matrixSeg1, matrixSeg2 ), 1)
Biskit/Dock/Complex.py:                insertColumns = oldN.array( [ [0] * insertZeros ] * oldN.size(cm,0) )
Biskit/Dock/Complex.py:                cm = oldN.concatenate( (matrixSeg1,insertColumns,matrixSeg2), 1)
Biskit/Dock/Complex.py:            return oldN.transpose( cm )
Biskit/Dock/Complex.py:        r = oldN.zeros( l_rec * l_lig )
Biskit/Dock/Complex.py:        rMask = oldN.ravel( oldN.outerproduct( rec_mask, lig_mask ) )
Biskit/Dock/Complex.py:        oldN.put( r, oldN.nonzero( rMask ), oldN.ravel( contacts ) )
Biskit/Dock/Complex.py:        return oldN.resize( r, (l_rec, l_lig))
Biskit/Dock/Complex.py:               oldN.shape( dist ) != ( oldN.sum(rec_mask), oldN.sum(lig_mask) ):
Biskit/Dock/Complex.py:            dist = self.__pairwiseDistances(oldN.compress( rec_mask, rec_xyz, 0),
Biskit/Dock/Complex.py:                                            oldN.compress( lig_mask, lig_xyz, 0) )
Biskit/Dock/Complex.py:        return oldN.less( dist, cutoff )
Biskit/Dock/Complex.py:                 oldN.array(residues_receptor x residues_ligand) where
Biskit/Dock/Complex.py:        recInd = oldN.concatenate((self.rec().resIndex(),
Biskit/Dock/Complex.py:        ligInd = oldN.concatenate((self.lig_model.resIndex(),
Biskit/Dock/Complex.py:        residueMatrix = oldN.zeros(( len(recInd)-1, len(ligInd)-1 ), oldN.Int)
Biskit/Dock/Complex.py:                if oldN.any( res2res ):
Biskit/Dock/Complex.py:            r.pw_dist = oldN.take( self.pw_dist, rec_pos, 1 )
Biskit/Dock/Complex.py:            r.pw_dist = oldN.take( r.pw_dist, lig_pos )
Biskit/Dock/Complex.py:        return self.take( oldN.nonzero( rec_mask ), oldN.nonzero( lig_mask ) )
Biskit/Dock/Complex.py:                 oldN.array(pair energy, surface energy, combined energy )
Biskit/Dock/Complex.py:            recCons = oldN.ones( self.rec().lenResidues() )
Biskit/Dock/Complex.py:            ligCons = oldN.ones( self.lig().lenResidues() )
Biskit/Dock/Complex.py:        surfMask = oldN.ravel(oldN.outerproduct( recSurf, ligSurf ))
Biskit/Dock/Complex.py:        missing = oldN.outerproduct( oldN.equal( recCons, 0), oldN.equal(ligCons,0))
Biskit/Dock/Complex.py:        cont = self.resContacts() * oldN.logical_not(missing)
Biskit/Dock/Complex.py:        consMat = oldN.outerproduct( recCons, ligCons )
Biskit/Dock/Complex.py:            random_score = oldN.sum(oldN.sum( ranMat * consMat ))/( ranNr*1.0 )
Biskit/Dock/Complex.py:            return oldN.sum(oldN.sum(score))/random_score
Biskit/Dock/Complex.py:            return oldN.sum(oldN.sum(score))/ oldN.sum(oldN.sum(cont))
Biskit/Dock/Complex.py:        result = oldN.concatenate( (r, oldN.transpose( [ t.tolist() ] )), 1)
Biskit/Dock/Complex.py:        result = oldN.concatenate( (result, oldN.array([[0,0,0,1]],oldN.Float32)), 0)
Biskit/Dock/Complex.py:        return result.astype(oldN.Float32)
Biskit/Dock/Complex.py:            y_new[i] = oldN.dot(r, y[i]) + t
Biskit/Dock/Complex.py:            y_new = oldN.dot(y, oldN.transpose(r)) + t
Biskit/Dock/Complex.py:        x_av = oldN.sum(x) / len(x)
Biskit/Dock/Complex.py:        y_av = oldN.sum(y) / len(y)
Biskit/Dock/Complex.py:        v, l, u = svd(oldN.dot(oldN.transpose(x), y))
Biskit/Dock/Complex.py:        r = oldN.dot(v, u)
Biskit/Dock/Complex.py:        t = x_av - oldN.dot(r, y_av)
Biskit/Dock/Complex.py:        diag1= oldN.diagonal(oldN.dot(u,oldN.transpose(u)))
Biskit/Dock/Complex.py:        diag2= oldN.diagonal(oldN.dot(v,oldN.transpose(v)))
Biskit/Dock/Complex.py:        dist= -oldN.dot(v,oldN.transpose(u))-oldN.transpose(oldN.dot(u,oldN.transpose(v)))
Biskit/Dock/Complex.py:        dist= oldN.transpose(oldN.asarray(map(lambda column,a:column+a, \
Biskit/Dock/Complex.py:                                   oldN.transpose(dist), diag1)))
Biskit/Dock/Complex.py:        return oldN.transpose(oldN.sqrt(oldN.asarray(
Biskit/Dock/Complex.py:        xyz_docked = oldN.compress( docked_pdb.maskCA(), docked_pdb.xyz )
Biskit/Dock/Complex.py:        xyz_template = oldN.compress( self.lig_model.maskCA(),
Biskit/Dock/Complex.py:        contProfile_lig = oldN.sum( cont )
Biskit/Dock/Complex.py:        contProfile_rec = oldN.sum( cont, 1 )
Biskit/Dock/Complex.py:        self.assertEqual( oldN.sum(contProfile_lig) + oldN.sum(contProfile_rec),
Biskit/Dock/ComplexRandomizer.py:        r.keep( oldN.nonzero( oldN.logical_not( r.maskH2O() ) ) )
Biskit/Dock/ComplexRandomizer.py:        dist = oldN.sqrt( oldN.sum( ( model.getXyz()-center )**2 , 1 ) )
Biskit/Dock/ComplexRandomizer.py:        scale = radius*1.0 / oldN.sqrt( oldN.sum( xyz**2 ) )
Biskit/Dock/ComplexRandomizer.py:        result = oldN.concatenate( (r, oldN.transpose( [ t.tolist() ] )), 1)
Biskit/Dock/ComplexRandomizer.py:        result = oldN.concatenate( (result, oldN.array([[0,0,0,1]], oldN.Float32)), 0 )
Biskit/Dock/ComplexTraj.py:                self.cr = oldN.sort( recChains ).tolist()
Biskit/Dock/ComplexTraj.py:        oldChainMap = oldN.take( self.ref.chainMap(), atomIndices )
Biskit/Dock/ComplexTraj.py:        return oldN.sum( oldN.array( r ) ) / ( 1. * len(r) )
Biskit/Dock/ComplexTraj.py:        r = oldN.ravel( r )
Biskit/Dock/ComplexTraj.py:        r = oldN.compress( r, r )
Biskit/Dock/ComplexTraj.py:        r = oldN.concatenate((range(1093,1191), range(0,1093), range(1191,1968)))
Biskit/Dock/ComplexTraj.py:        self.assertEqual( oldN.sum(oldN.ravel(contactMat)), 308 )
Biskit/Dock/ComplexTraj.py:    #r = oldN.concatenate((range(1093,1191), range(0,1093), range(1191,1968)))
Biskit/Dock/ContactMaster.py:        h_rec = oldN.nonzero( RC.rec_model.maskH() )
Biskit/Dock/ContactMaster.py:        h_lig = oldN.nonzero( RC.lig_model.maskH() )
Biskit/Dock/ContactMaster.py:        m_rec = oldN.zeros( len( NC.rec_model ), oldN.Int )
Biskit/Dock/ContactMaster.py:        oldN.put( m_rec, i_rec, 1 )
Biskit/Dock/ContactMaster.py:        m_lig = oldN.zeros( len( NC.lig_model ), oldN.Int )
Biskit/Dock/ContactMaster.py:        oldN.put( m_lig, i_lig, 1 )
Biskit/Dock/ContactMaster.py:            if_rec = NC.rec_model.res2atomMask( oldN.sum( res_contacts, 1) )
Biskit/Dock/ContactMaster.py:            if_lig = NC.lig_model.res2atomMask( oldN.sum( res_contacts, 0) )
Biskit/Dock/ContactMaster.py:            mask_interface = oldN.concatenate( (if_rec, if_lig) )
Biskit/Dock/ContactMaster.py:            if_lig = oldN.compress( mask_lig, if_lig )
Biskit/Dock/ContactMaster.py:            mask_interface_ref = oldN.concatenate( (if_rec, if_lig) )
Biskit/Dock/ContactMaster.py:        i_r_surf = oldN.nonzero( r[ rec_models[0].source ].\
Biskit/Dock/ContactMaster.py:        i_l_surf = oldN.nonzero( l[ lig_models[0].source ].\
Biskit/Dock/ContactMaster.py:            self.assertAlmostEqual(oldN.sum(self.cl_cont.valuesOf('fnac_10')),
Biskit/Dock/ContactSlave.py:                ref = oldN.ravel( self.c_ref_atom_4_5 )
Biskit/Dock/ContactSlave.py:                c['fnac_4.5'] = oldN.sum( oldN.ravel(contacts) * ref )\
Biskit/Dock/ContactSlave.py:                 / float( oldN.sum(ref))
Biskit/Dock/ContactSlave.py:                ref = oldN.ravel( self.c_ref_atom_10 )
Biskit/Dock/ContactSlave.py:                c['fnac_10'] = oldN.sum( oldN.ravel(contacts) * ref ) \
Biskit/Dock/ContactSlave.py:                 / float( oldN.sum(ref))
Biskit/Dock/ContactSlave.py:                    ref = oldN.ravel( self.c_ref_res_4_5 )
Biskit/Dock/ContactSlave.py:                    c['fnrc_4.5'] = oldN.sum(oldN.ravel(res_cont)*ref) \
Biskit/Dock/ContactSlave.py:                     /float(oldN.sum(ref))
Biskit/Dock/ContactSlave.py:                ref = oldN.ravel( self.c_ref_ratom_10 )
Biskit/Dock/ContactSlave.py:                c['fnarc_10'] = oldN.sum( oldN.ravel(contacts) * ref )\
Biskit/Dock/ContactSlave.py:                 / float( oldN.sum(ref))
Biskit/Dock/Docker.py:                idx = oldN.nonzero( cMap == chain )
Biskit/Dock/HexParser.py:                        matrix = oldN.array(matrix, oldN.Float32)
Biskit/Dock/hexTools.py:    surf_xyz = oldN.compress( mask*surf_mask, model.getXyz(), 0 )
Biskit/Dock/hexTools.py:    dist = oldN.sqrt( oldN.sum( (surf_xyz-center)**2 , 1 ) )
Biskit/Dock/hexTools.py:    rec_surf_mask = oldN.greater( recModel.profile('relAS'), 95 )
Biskit/Dock/hexTools.py:    lig_surf_mask = oldN.greater( ligModel.profile('relAS'), 95 )
Biskit/Dock/PatchGeneratorFromOrbit.py:        return oldN.sqrt( oldN.sum( oldN.power( xyz - point, 2), 1 ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:        scale = self.orbit*1.0 / oldN.sqrt( oldN.sum( xyz**2, 1 ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:        r = oldN.array( [ scale[i]*xyz[i] for i in range(n) ] )
Biskit/Dock/PatchGeneratorFromOrbit.py:        order = oldN.argsort( dist )
Biskit/Dock/PatchGeneratorFromOrbit.py:        r = oldN.zeros( len( self.model ), 'i' )
Biskit/Dock/PatchGeneratorFromOrbit.py:        oldN.put( r, order[:nAtoms], 1 )
Biskit/Dock/PatchGeneratorFromOrbit.py:        n_atoms= len( oldN.nonzero( patch_mask ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:        i_dist = oldN.argsort( dist )[:n_atoms]
Biskit/Dock/PatchGeneratorFromOrbit.py:        result = oldN.zeros( len( patch_mask ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:        oldN.put( result, i_dist, 1 )
Biskit/Dock/PatchGeneratorFromOrbit.py:        return oldN.take( points, oldN.argsort( dist ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:            exclude = oldN.zeros( self.model.lenAtoms(), 'i' )
Biskit/Dock/PatchGeneratorFromOrbit.py:            exclude_all = oldN.zeros( self.model.lenAtoms(), 'i' )
Biskit/Dock/PatchGeneratorFromOrbit.py:        if not oldN.any( tabu ):
Biskit/Dock/PatchGeneratorFromOrbit.py:            if oldN.sum( m * exclude ) <= max_overlap \
Biskit/Dock/PatchGeneratorFromOrbit.py:               and oldN.sum( m * exclude_all ) == 0:
Biskit/Dock/PatchGeneratorFromOrbit.py:    profile = oldN.sum( oldN.array(r) )
Biskit/Dock/PatchGeneratorFromOrbit.py:    ms = [ model.take( oldN.nonzero(mask) ) for mask in r ]
Biskit/Dock/PatchGeneratorFromOrbit.py:    rec_if = oldN.sum( cont, 1 )
Biskit/Dock/PatchGeneratorFromOrbit.py:    lig_if = oldN.sum( cont, 0 )
Biskit/Dock/PatchGeneratorFromOrbit.py:    c2c = oldN.sqrt( oldN.sum( (rec.center() - lig.center())**2, 0 ) )
Biskit/Dock/PatchGeneratorFromOrbit.py:    excl = oldN.compress( oldN.ones( len( rec_if ) ), rec_if )
Biskit/Dock/PatchGeneratorFromOrbit.py:    pm = test( rec, c2c, nAtoms=len(oldN.nonzero(rec_if)), exclude=rec_if )
Biskit/DSSP.py:        if self.model.lenAtoms() == oldN.sum(self.model.maskCA):
Biskit/EnsembleTraj.py:        mI = oldN.array( mI )
Biskit/EnsembleTraj.py:        mI = oldN.take( mI, range( -1, oldN.shape( mI )[1], step )[1:], 1 )
Biskit/EnsembleTraj.py:        mI = oldN.transpose( mI )
Biskit/EnsembleTraj.py:        return self.takeFrames( oldN.ravel( mI ))
Biskit/EnsembleTraj.py:            r = oldN.take( r, range( 0, len( r ), step ) ).tolist()
Biskit/EnsembleTraj.py:        result = oldN.zeros( self.lenFrames() )
Biskit/EnsembleTraj.py:            oldN.put( result, self.memberIndices( member ), 1 )
Biskit/EnsembleTraj.py:                oldN.put( result, self.memberIndices( m ), 1 )
Biskit/EnsembleTraj.py:            fi = oldN.array( [ self.memberIndices( i ) for i in mIndices ] )
Biskit/EnsembleTraj.py:            fi = oldN.ravel( oldN.transpose( fi ) )
Biskit/EnsembleTraj.py:        r.frames = oldN.array(frames) 
Biskit/EnsembleTraj.py:#                r.pc['p'] = oldN.concatenate( (self.pc['p'], traj[0].pc['p']),0)
Biskit/EnsembleTraj.py:#                r.pc['u'] = oldN.concatenate( (self.pc['u'], traj[0].pc['u']),0)
Biskit/EnsembleTraj.py:        return self.takeMembers( oldN.nonzero( mask ) )
Biskit/EnsembleTraj.py:        i.remove( oldN.array(indices) )
Biskit/EnsembleTraj.py:            oldN.put( self.frames, indices, traj.frames )
Biskit/EnsembleTraj.py:        mean, sd = oldN.average( slopes ), M.SD( slopes )
Biskit/EnsembleTraj.py:                                 oldN.sum( self.tr.profile('rms_CA_av') ), 2 )
Biskit/EnsembleTraj.py:        self.t = self.t2.compressMembers( oldN.logical_not( self.o ) )
Biskit/FuzzyCluster.py:    d1 = oldN.diagonal(oldN.dot(x, oldN.transpose(x)))
Biskit/FuzzyCluster.py:    d2 = oldN.diagonal(oldN.dot(y, oldN.transpose(y)))
Biskit/FuzzyCluster.py:    a1 = oldN.add.outer(d1,d2)
Biskit/FuzzyCluster.py:    a2 = oldN.dot(x, oldN.transpose(y))
Biskit/FuzzyCluster.py:    return oldN.sqrt(squared_distance_matrix(x, y))
Biskit/FuzzyCluster.py:        self.data = oldN.array(data, oldN.Float)
Biskit/FuzzyCluster.py:        self.npoints, self.dimension = oldN.shape(data)
Biskit/FuzzyCluster.py:        d2 = oldN.clip( d2, oldN.power(1e200, 1-self.w), 1e300 )
Biskit/FuzzyCluster.py:        q = oldN.power(d2, 1. / (1. - self.w))
Biskit/FuzzyCluster.py:        return q / oldN.sum(q)
Biskit/FuzzyCluster.py:        p = oldN.power(msm, self.w)
Biskit/FuzzyCluster.py:        ccenter = oldN.transpose(oldN.dot(p, self.data))
Biskit/FuzzyCluster.py:        return oldN.transpose(ccenter / oldN.sum(p, 1))
Biskit/FuzzyCluster.py:        p = oldN.power(msm, self.w)
Biskit/FuzzyCluster.py:        product = oldN.dot(p, oldN.transpose(d2))
Biskit/FuzzyCluster.py:        return oldN.trace(product)
Biskit/FuzzyCluster.py:        return oldN.transpose(r / oldN.sum(r))
Biskit/FuzzyCluster.py:        centropy = oldN.diagonal(oldN.dot(self.msm,
Biskit/FuzzyCluster.py:                                    oldN.transpose(oldN.log(self.msm))))
Biskit/FuzzyCluster.py:        return oldN.sum(self.clusterEntropy())
Biskit/FuzzyCluster.py:        p = oldN.power(self.msm, self.w)
Biskit/FuzzyCluster.py:        return (self.n_cluster*oldN.sum(oldN.sum(p))-
Biskit/FuzzyCluster.py:        return oldN.sum(oldN.power(self.msm, self.w), 1)/self.npoints
Biskit/FuzzyCluster.py:        return oldN.sum(self.clusterPartitionCoefficient())
Biskit/FuzzyCluster.py:        centropy = oldN.sum(-oldN.log(self.msm)*\
Biskit/FuzzyCluster.py:        self.x = oldN.concatenate((x1, x2, x3))
Biskit/FuzzyCluster.py:        self.assertEqual( oldN.shape(self.centers), (5, 2) )
Biskit/gnuplot.py:        x = oldN.arange(10)
Biskit/gnuplot.py:        plot( oldN.transpose(oldN.array([x, y1])), oldN.transpose(oldN.array([x, y2])))
Biskit/hist.py:    data = oldN.array(data, oldN.Float)
Biskit/hist.py:        min = oldN.minimum.reduce(data)
Biskit/hist.py:        max = oldN.maximum.reduce(data)
Biskit/hist.py:        data = oldN.repeat(data,
Biskit/hist.py:                              oldN.logical_and(oldN.less_equal(data, max),
Biskit/hist.py:                                                  oldN.greater_equal(data, min)))
Biskit/hist.py:    data = oldN.floor((data - min)/bin_width).astype(oldN.Int)
Biskit/hist.py:    histo = oldN.add.reduce(oldN.equal(
Biskit/hist.py:        oldN.arange(nbins)[:,oldN.NewAxis], data), -1)
Biskit/hist.py:    histo[-1] = histo[-1] + oldN.add.reduce(oldN.equal(nbins, data))
Biskit/hist.py:    bins = min + bin_width*(oldN.arange(nbins)+0.5)
Biskit/hist.py:    return oldN.transpose(oldN.array([bins, histo]))
Biskit/hist.py:        i = oldN.sum(h)[1]*binWidth
Biskit/hist.py:    return oldN.array(h)
Biskit/hist.py:        self.x = oldN.arange( 4, 12, 1.2 )
Biskit/hist.py:        self.assert_( oldN.all( self.data == self.EXPECT) )
Biskit/hist.py:    EXPECT= oldN.array([[  4. ,   0. ],
Biskit/Hmmer.py:        profileDic['seqNr'] = oldN.transpose( oldN.take( prob, (0,),1 ) )
Biskit/Hmmer.py:        profileDic['emmScore'] = oldN.array(prob)[:,1:]
Biskit/Hmmer.py:        ent = [ oldN.resize( self.entropy(e, nullProb), (1,20) )[0] for e in emmProb ]
Biskit/Hmmer.py:        profileDic['ent'] = oldN.array(ent)
Biskit/Hmmer.py:        proba = oldN.array(prob)[:,1:]
Biskit/Hmmer.py:        # test set all to oldN.sum( abs( probabilities ) )
Biskit/Hmmer.py:            p2 += [ oldN.resize( oldN.sum( oldN.absolute( p[i] )), oldN.shape( p[i] ) ) ]
Biskit/Hmmer.py:            p_scale = (p[i] - oldN.average(p[i]) )/ math.SD(p[i])
Biskit/Hmmer.py:            p4 += [ oldN.resize( p_scale[oldN.argmax( oldN.array(p_scale) )] ,
Biskit/Hmmer.py:                              oldN.shape( p[i] ) ) ]
Biskit/Hmmer.py:        nullProb = oldN.power( 2, oldN.array( nullEmm )/1000.0 )*(1./20)
Biskit/Hmmer.py:        emmProb = nullProb * oldN.power( 2, ( emmScore/1000.0) )
Biskit/Hmmer.py:        if oldN.sum( emmProb ) == 0.:
Biskit/Hmmer.py:        return oldN.sum( emmProb * oldN.log(emmProb/nullProb) )
Biskit/Hmmer.py:            mask = oldN.ones( len(s) )
Biskit/Hmmer.py:            oldN.put( mask, hmmGap[i], 0 )
Biskit/Hmmer.py:                score = oldN.compress( mask, s, 0 )
Biskit/Hmmer.py:                score = oldN.concatenate( ( oldN.compress( mask, s, 0 ), score ) )
Biskit/Hmmer.py:            return oldN.array( lstOrAr )
Biskit/Hmmer.py:        overlap = oldN.greater( oldN.greater(p0,0) + oldN.greater(p1,0), 1 )
Biskit/Hmmer.py:        if oldN.sum( overlap ) <= maxOverlap:
Biskit/Hmmer.py:            oldN.put( p1, oldN.nonzero( overlap ), 0 )
Biskit/Hmmer.py:            oldN.put( p0, oldN.nonzero( overlap ), 0 )
Biskit/match2seq.py:    mask = oldN.ones( len(seq) )
Biskit/match2seq.py:    mask_1 = oldN.zeros( len( seqNr_1 ) )
Biskit/match2seq.py:    mask_2 = oldN.zeros( len( seqNr_2 ) )
Biskit/match2seq.py:    seqAA_1 = oldN.compress( mask1, seqAA_1 ).tolist()
Biskit/match2seq.py:    seqNr_1 = oldN.compress( mask1, seqNr_1 ).tolist()
Biskit/match2seq.py:    seqAA_2 = oldN.compress( mask2, seqAA_2 ).tolist()
Biskit/match2seq.py:    seqNr_2 = oldN.compress( mask2, seqNr_2 ).tolist()
Biskit/match2seq.py:    oldN.put( mask_1, seqNr_1 , 1 )
Biskit/match2seq.py:    oldN.put( mask_2, seqNr_2 , 1 )
Biskit/match2seq.py:        self.assert_( oldN.all(mask1 == self.EXPECT[0] ) )
Biskit/match2seq.py:        self.assert_( oldN.all(mask2 == self.EXPECT[1] ) )
Biskit/match2seq.py:        self.assert_( oldN.all( mask1 == oldN.zeros( len(seq1 ) )) )
Biskit/match2seq.py:        self.assert_( oldN.all( mask2 == oldN.zeros( len(seq2 ) )) )
Biskit/match2seq.py:    EXPECT =  oldN.array([1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
Biskit/match2seq.py:                       1, 1, 1, 1],oldN.Int),\
Biskit/match2seq.py:              oldN.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
Biskit/match2seq.py:                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],oldN.Int)
Biskit/mathUtils.py:    normalized by C{ oldN.sum( a ) }
Biskit/mathUtils.py:    return oldN.add.accumulate( a ) / oldN.sum( a )
Biskit/mathUtils.py:        avg = oldN.average(x)
Biskit/mathUtils.py:    return oldN.sum(oldN.power(oldN.array(x) - avg, 2)) / (len(x) - 1.)
Biskit/mathUtils.py:    return oldN.sqrt(variance(x, avg))
Biskit/mathUtils.py:    return oldN.sum(wx)/oldN.sum(w)
Biskit/mathUtils.py:    return ( oldN.sum(w) / ( (oldN.sum(w)**2-oldN.sum(w**2)) ) ) * oldN.sum(w*(x-wm)**2)
Biskit/mathUtils.py:    return oldN.sqrt( wVar(x, w) )
Biskit/mathUtils.py:    if type(a) is list:  a = oldN.array( a )
Biskit/mathUtils.py:    if type(b) is list:  b = oldN.array( b )
Biskit/mathUtils.py:    a = oldN.ravel( a )
Biskit/mathUtils.py:    b = oldN.ravel( b )
Biskit/mathUtils.py:    return oldN.sum( a==b ) == len(a)
Biskit/mathUtils.py:    diag1 = oldN.diagonal( oldN.dot( u, oldN.transpose(u) ) )
Biskit/mathUtils.py:    diag2 = oldN.diagonal( oldN.dot( v, oldN.transpose(v) ) )
Biskit/mathUtils.py:    dist = -oldN.dot( v,oldN.transpose(u) )\
Biskit/mathUtils.py:         -oldN.transpose( oldN.dot( u, oldN.transpose(v) ) )
Biskit/mathUtils.py:    dist = oldN.transpose( oldN.asarray( map( lambda column,a:column+a, \
Biskit/mathUtils.py:                                        oldN.transpose(dist), diag1) ) )
Biskit/mathUtils.py:    return oldN.transpose( oldN.sqrt( oldN.asarray(
Biskit/mathUtils.py:    r = oldN.zeros( length )
Biskit/mathUtils.py:    oldN.put( r, pos, 1 ) 
Biskit/mathUtils.py:    while nOnes != oldN.sum(r):
Biskit/mathUtils.py:        oldN.put( r, pos, 1 )
Biskit/mathUtils.py:    a,b = oldN.shape( matrix )
Biskit/mathUtils.py:        if len(mask) == len( oldN.ravel(matrix) ):
Biskit/mathUtils.py:            array = oldN.compress( mask, oldN.ravel(matrix) )
Biskit/mathUtils.py:        if len(mask) != len( oldN.ravel(matrix) ):
Biskit/mathUtils.py:                %(len( oldN.ravel(matrix) ), len(mask)))
Biskit/mathUtils.py:        array = oldN.ravel(matrix)
Biskit/mathUtils.py:    nOnes = int( oldN.sum( array ) )
Biskit/mathUtils.py:    ranArray = oldN.zeros( lenArray )
Biskit/mathUtils.py:        r = oldN.zeros(a*b)
Biskit/mathUtils.py:        oldN.put( r, oldN.nonzero(mask), ranArray)
Biskit/mathUtils.py:        return oldN.reshape( r, (a,b) )
Biskit/mathUtils.py:        return  oldN.reshape( ranArray, (a,b) )
Biskit/mathUtils.py:    return [ oldN.average( y[i-margin : i+margin] )
Biskit/mathUtils.py:            l.append(oldN.average(slice))
Biskit/mathUtils.py:            l.append(oldN.average(slice))
Biskit/mathUtils.py:    return oldN.array(l)
Biskit/mathUtils.py:    curve = oldN.array( curve )
Biskit/mathUtils.py:    c = oldN.zeros( oldN.shape(curve), curve.dtype )
Biskit/mathUtils.py:    assert len( oldN.shape( c ) ) == 2
Biskit/mathUtils.py:    mask = oldN.greater_equal( c[:,1], start )
Biskit/mathUtils.py:    mask *= oldN.less_equal( c[:,1], stop )
Biskit/mathUtils.py:    c = oldN.compress( mask, c, axis=0 )
Biskit/mathUtils.py:    c = oldN.concatenate((oldN.array([[c[0,0], start],]), c,
Biskit/mathUtils.py:                       oldN.array([[c[-1,0],stop ],])) )
Biskit/mathUtils.py:    return oldN.sum(areas1) + oldN.sum(areas2)
Biskit/mathUtils.py:    result['shape'] = oldN.shape( cm )
Biskit/mathUtils.py:    result['nonzero'] = oldN.nonzero( oldN.ravel( cm ) )
Biskit/mathUtils.py:    m = oldN.zeros( oldN.cumproduct( s )[-1], oldN.Int)
Biskit/mathUtils.py:    oldN.put( m, pcm['nonzero'], 1 )
Biskit/mathUtils.py:    return oldN.reshape( m, s )
Biskit/mathUtils.py:    result['shape'] = oldN.shape( cm )
Biskit/mathUtils.py:    result['lst'] = oldN.ravel( cm ).tolist()
Biskit/mathUtils.py:    return oldN.reshape( lcm['lst'], s )
Biskit/mathUtils.py:    cos_alpha = oldN.cos(alpha); sin_alpha = oldN.sin(alpha)
Biskit/mathUtils.py:    cos_beta  = oldN.cos(beta);  sin_beta  = oldN.sin(beta)
Biskit/mathUtils.py:    cos_gamma = oldN.cos(gamma); sin_gamma = oldN.sin(gamma)
Biskit/mathUtils.py:    R = oldN.zeros((3,3), oldN.Float32)
Biskit/mathUtils.py:    alpha = RandomArray.random() * 2 * oldN.pi
Biskit/mathUtils.py:    gamma = RandomArray.random() * 2 * oldN.pi
Biskit/mathUtils.py:    beta  = oldN.arccos(2*(RandomArray.random() - 0.5))
Biskit/mathUtils.py:    if type( a ) is oldN.arraytype:
Biskit/mathUtils.py:    if type( b ) is oldN.arraytype:
Biskit/mathUtils.py:    x, y = oldN.array( x, oldN.Float64), oldN.array( y, oldN.Float64)
Biskit/mathUtils.py:    av_x = oldN.average( x )
Biskit/mathUtils.py:    av_y = oldN.average( y )
Biskit/mathUtils.py:    ss_xy = oldN.sum( x * y ) - n * av_x * av_y
Biskit/mathUtils.py:    ss_xx = oldN.sum( x * x ) - n * av_x * av_x
Biskit/mathUtils.py:    ss_yy = oldN.sum( y * y ) - n * av_y * av_y
Biskit/mathUtils.py:    r = oldN.sqrt( oldN.sum( xyz**2, 1 ) )
Biskit/mathUtils.py:    p = oldN.arccos( xyz[:,2] / r )
Biskit/mathUtils.py:    return oldN.transpose( oldN.concatenate( ([r],[t],[p]) ) )
Biskit/mathUtils.py:    x = rtp[:,0] * oldN.cos( rtp[:,1] ) * oldN.sin( rtp[:,2] )
Biskit/mathUtils.py:    y = rtp[:,0] * oldN.sin( rtp[:,1] ) * oldN.sin( rtp[:,2] )
Biskit/mathUtils.py:    z = rtp[:,0] * oldN.cos( rtp[:,2] )
Biskit/mathUtils.py:    return oldN.transpose( oldN.concatenate( ([x],[y],[z]) ) )
Biskit/mathUtils.py:        center = oldN.average( xyz )
Biskit/mathUtils.py:        radius = max( oldN.sqrt( oldN.sum( oldN.power( xyz - center, 2 ), 1 ) ) )
Biskit/mathUtils.py:    >>> m=rotateAxis(pi, oldN.array([1,0,0]))
Biskit/mathUtils.py:    vector = vector / oldN.linalg.norm(vector)
Biskit/mathUtils.py:    c=oldN.cos(theta)
Biskit/mathUtils.py:    s=oldN.sin(theta)
Biskit/mathUtils.py:    rot=oldN.zeros((3,3), "d")
Biskit/mathUtils.py:        return -math.pow(oldN.abs(x), 1.0/3.0) 
Biskit/mathUtils.py:    mask = oldN.ones( len(a) )
Biskit/mathUtils.py:    out  = oldN.zeros( len(a) )
Biskit/mathUtils.py:        return out, oldN.median(a), oldN.std(a)
Biskit/mathUtils.py:        b  = oldN.compress( oldN.logical_not(out), a )
Biskit/mathUtils.py:        me = oldN.median( b )
Biskit/mathUtils.py:        sd = oldN.std( b )
Biskit/mathUtils.py:        bz = oldN.absolute((oldN.array( a ) - me) / sd)  # pseudo z-score of each value
Biskit/mathUtils.py:        if (oldN.sum(o) == oldN.sum(out)) or (oldN.sum(o) > len(a) - 3):
Biskit/mathUtils.py:        self.d = oldN.array([[20.,30.,40.],[23., 31., 50.]])
Biskit/mathUtils.py:        self.assertAlmostEqual( oldN.sum( SD(self.a) ), self.EXPECT )
Biskit/mathUtils.py:        self.c = zip( oldN.arange(0,1.01,0.1), oldN.arange(0,1.01,0.1) )
Biskit/mathUtils.py:    EXPECT = oldN.sum( oldN.array([ 2.12132034,  0.70710678,  7.07106781]) )
Biskit/MatrixPlot.py:        values = oldN.array(values)
Biskit/MatrixPlot.py:            vmin = oldN.amin( matrix )
Biskit/MatrixPlot.py:            vmax = oldN.amax( matrix )
Biskit/MatrixPlot.py:        s = oldN.shape( self.matrix )
Biskit/MatrixPlot.py:        r = oldN.take( a, range( 0, len(a), step ), axis=0 )
Biskit/MatrixPlot.py:        r = oldN.take( r, range( 0, len(r[0]), step ), axis=1 )
Biskit/MatrixPlot.py:        z = oldN.zeros((n,n), oldN.Float)
Biskit/MatrixPlot.py:        for i in range(oldN.shape(z)[0]):
Biskit/MatrixPlot.py:            for j in range(oldN.shape(z)[1]):
Biskit/MatrixPlot.py:                z[i,j] = oldN.exp(-0.01*((i-n/2)**2+(j-n/2)**2))
Biskit/Mod/Analyse.py:            identities[folder] = oldN.sum(lst[0][1:])/nb_templates
Biskit/Mod/Benchmark.py:        outliers_mask = oldN.logical_not(fitted_model_if.profile("rms_outliers"))
Biskit/Mod/Benchmark.py:                                                 - oldN.sum(outliers_mask)) / len(outliers_mask)
Biskit/Mod/Benchmark.py:        model.info["rmsd2ref_ca_outliers"] = 1.*(oldN.sum(mask_CA) \
Biskit/Mod/Benchmark.py:                                                 - oldN.sum(oldN.compress(mask_CA, outliers_mask))) \
Biskit/Mod/Benchmark.py:             / oldN.sum(mask_CA)
Biskit/Mod/Benchmark.py:            rmsd = oldN.sqrt( (oldN.power(coord1[i][0]-coord2[i][0],2) +  \
Biskit/Mod/Benchmark.py:                            oldN.power(coord1[i][1]-coord2[i][1],2 )+ \
Biskit/Mod/Benchmark.py:                            oldN.power(coord1[i][2]-coord2[i][2],2 )))
Biskit/Mod/Benchmark.py:        mask_casting = oldN.zeros(len(pdb_list[0]))
Biskit/Mod/Benchmark.py:        oldN.put(mask_casting, imodel, 1)
Biskit/Mod/Benchmark.py:        atom_mask = oldN.zeros(len(pdb_list[0]))
Biskit/Mod/Benchmark.py:        oldN.put(atom_mask,imodel,1)
Biskit/Mod/Benchmark.py:        mask_final_ref = oldN.compress(mask_casting, amask)
Biskit/Mod/CheckIdentities.py:                nb_cov_res = oldN.sum( oldN.greater(template_info, 0) )
Biskit/Mod/TemplateSearcher.py:        return ids_in_cluster[ oldN.argmin( resolutions ) ]
Biskit/molTools.py:            dist = oldN.sqrt( sum( (d_xyz - a_xyz)**2 ) )
Biskit/molTools.py:                d_len = oldN.sqrt( sum( (d_vec)**2 ) )
Biskit/molTools.py:                a_len = oldN.sqrt( sum( (a_vec)**2 ) )
Biskit/molTools.py:                da_dot = oldN.dot( d_vec, a_vec)
Biskit/molTools.py:                angle = 180 - oldN.arccos( da_dot / (d_len * a_len) )*180/oldN.pi
Biskit/molTools.py:    dist = oldN.sqrt( oldN.sum( (resModel.xyz - model.xyz[i])**2 , 1) )
Biskit/molTools.py:    dist[ oldN.argmin(dist) ] = 100.
Biskit/molTools.py:    pos_shortest =  oldN.nonzero( dist == min(dist) )[0]
Biskit/molTools.py:        self.r = oldN.sum(oldN.ravel(hb[3:5])) + oldN.sum(xyz)
Biskit/molUtils.py:euler        = oldN.e
Biskit/molUtils.py:        self.assertEqual( oldN.sum(cmp), 159 )
Biskit/msms.py:        xyzr = oldN.reshape( xyzr, ( len(xyzr)/4, 4 ) )
Biskit/msms.py:        xyzr = oldN.concatenate( ( xyz, oldN.transpose([r]) ) ,axis=1 )
Biskit/PDBCleaner.py:            self.logWrite('Removed ' + str(oldN.sum(mask)) +
Biskit/PDBCleaner.py:        return oldN.sum( mask )
Biskit/PDBCleaner.py:        i = oldN.take( model.chainIndex(), chains ) 
Biskit/PDBCleaner.py:        index = oldN.concatenate( (model.chainIndex(), [len(model)]) )
Biskit/PDBCleaner.py:        i = oldN.take( index, oldN.array( chains ) + 1 ) - 1
Biskit/PDBCleaner.py:            capN = M.union( capN, oldN.array( end_broken ) + 1 )
Biskit/PDBDope.py:        if not oldN.alltrue( mask ):
Biskit/PDBDope.py:        xyz = oldN.compress( mHeavy, self.m.getXyz(), 0 )
Biskit/PDBDope.py:            mSurf = oldN.ones( self.m.lenAtoms() )
Biskit/PDBDope.py:        surf_pos = oldN.nonzero( mSurf )
Biskit/PDBDope.py:            dist = oldN.sum(( xyz - self.m.xyz[i])**2, 1)
Biskit/PDBDope.py:            contacts += [ oldN.sum( oldN.less(dist, radius**2 )) -1]
Biskit/PDBDope.py:            self.m.maskHeavy() * oldN.logical_not( self.m.maskSolvent() )
Biskit/PDBDope.py:            self.assert_( oldN.all( m_ref[k] == self.M[k]) )
Biskit/PDBDope.py:            pm.colorAtoms( 'm', oldN.clip(self.M.profile('relAS'), 0.0, 100.0) )
Biskit/PDBDope.py:            pm.colorAtoms( 'm', oldN.clip(self.M.profile('cons_ent'), 0.0, 100.0) )
Biskit/PDBModel.py:            m = self.compress( oldN.logical_not( mask ) )
Biskit/PDBModel.py:            mask = oldN.zeros( self.atoms.profLength() )
Biskit/PDBModel.py:            oldN.put( mask, ter_atoms, 1 )
Biskit/PDBModel.py:        if self.xyz is not None and type( self.xyz ) is not oldN.ndarray:
Biskit/PDBModel.py:            self.xyz = oldN.array( self.xyz )
Biskit/PDBModel.py:        if self._resIndex is not None and type( self._resIndex ) is not oldN.ndarray:
Biskit/PDBModel.py:            self._resIndex = oldN.array( self._resIndex )
Biskit/PDBModel.py:        if self._chainIndex is not None and type(self._chainIndex) is not oldN.ndarray:
Biskit/PDBModel.py:            self._chainIndex = oldN.array( self._chainIndex )
Biskit/PDBModel.py:            return oldN.zeros( (0,3), oldN.float32 )
Biskit/PDBModel.py:        return oldN.compress( mask, self.xyz, 0 )
Biskit/PDBModel.py:        return [ r[i] for i in oldN.nonzero( mask ) ]
Biskit/PDBModel.py:                if type( self.residues[ key ] ) is oldN.arraytype:
Biskit/PDBModel.py:                if type( self.atoms[ key ] ) is oldN.arraytype:
Biskit/PDBModel.py:            if type( self.xyz ) is oldN.arraytype and self.xyz.dtype.char != 'f':
Biskit/PDBModel.py:                self.xyz = self.xyz.astype(oldN.Float32)
Biskit/PDBModel.py:            m_first = oldN.zeros( self.lenAtoms() )
Biskit/PDBModel.py:            oldN.put( m_first, firstAtm, 1 )
Biskit/PDBModel.py:            firstAtm = oldN.nonzero( m_first )
Biskit/PDBModel.py:        resI = oldN.concatenate( (resI, [len(self)] ) )
Biskit/PDBModel.py:                terIndex = oldN.array( self.chainIndex( breaks=(ter==3) ).tolist()[1:] )
Biskit/PDBModel.py:                terIndex = oldN.nonzero( self.atoms['after_ter'] )
Biskit/PDBModel.py:            return oldN.array( result )
Biskit/PDBModel.py:          >>> mask = oldN.array( [ a == 'CA' for a in m.atoms['name'] ] )
Biskit/PDBModel.py:            return oldN.array( map( cond, self.atoms[ key ] ) )
Biskit/PDBModel.py:            return oldN.array( [ x in cond for x in self.atoms[key] ] )
Biskit/PDBModel.py:            return oldN.array( self.atoms[key] ) == cond
Biskit/PDBModel.py:                mask = oldN.logical_not(self.maskSolvent()) * mask
Biskit/PDBModel.py:        return oldN.logical_not( self.maskHeavy() )
Biskit/PDBModel.py:        return oldN.array(
Biskit/PDBModel.py:        return oldN.nonzero( self.maskFrom( key, cond) )
Biskit/PDBModel.py:            return oldN.nonzero( self.maskF( what) )
Biskit/PDBModel.py:        if type( what ) is list or type( what ) is oldN.arraytype:
Biskit/PDBModel.py:               (isinstance(what, oldN.ndarray) and what.dtype in [int, bool]):
Biskit/PDBModel.py:                    return oldN.nonzero( what )
Biskit/PDBModel.py:            return oldN.array( [what], oldN.Int )
Biskit/PDBModel.py:        if type( what ) == list or type( what ) is oldN.arraytype:
Biskit/PDBModel.py:               (isinstance(what, oldN.ndarray) and what.dtype in [int, bool]):
Biskit/PDBModel.py:                    r = oldN.zeros( self.lenAtoms(),oldN.Int )
Biskit/PDBModel.py:                    oldN.put( r, what, 1 )
Biskit/PDBModel.py:        index = oldN.concatenate( (index, [len_i]) )
Biskit/PDBModel.py:        return oldN.repeat( range(len(delta)), delta.astype( oldN.int32) )
Biskit/PDBModel.py:            imap = oldN.concatenate( (imap, [imap[-1]] ) )
Biskit/PDBModel.py:            # Numeric: delta = oldN.take( imap, range(1, len(imap) ) ) - imap[:-1]
Biskit/PDBModel.py:            r = oldN.nonzero( delta ) + 1
Biskit/PDBModel.py:            return oldN.concatenate( ( [0], r ) )
Biskit/PDBModel.py:            return oldN.zeros(0)
Biskit/PDBModel.py:        index = oldN.concatenate( (index, [len_i]) )
Biskit/PDBModel.py:        return oldN.repeat( mask, delta.astype( oldN.int32 ) )
Biskit/PDBModel.py:            return i, oldN.array( [], int )
Biskit/PDBModel.py:        stop = oldN.concatenate( (index[1:], [len_i]) ) - 1
Biskit/PDBModel.py:        ifrom = oldN.take( index, i )
Biskit/PDBModel.py:        ito   = oldN.take( stop, i )
Biskit/PDBModel.py:        rindex   = oldN.concatenate( ([0], oldN.cumsum( rangelen[:-1] )) )
Biskit/PDBModel.py:        ri    = oldN.repeat( ifrom,  rangelen )
Biskit/PDBModel.py:        delta = oldN.repeat( rindex, rangelen )
Biskit/PDBModel.py:        ri =  ri + oldN.arange( len(ri), dtype=oldN.int32 ) - delta
Biskit/PDBModel.py:        res_indices = self.atom2resIndices( oldN.nonzero( atomMask) )
Biskit/PDBModel.py:        r = oldN.zeros( self.lenResidues() )
Biskit/PDBModel.py:        oldN.put( r, res_indices, 1 )
Biskit/PDBModel.py:        new_resmap = oldN.take( self.resMap(), indices )
Biskit/PDBModel.py:        return oldN.take( new_resmap, resIndex )
Biskit/PDBModel.py:        indices = copy.copy( oldN.array( indices ) )
Biskit/PDBModel.py:        negatives = oldN.flatnonzero( indices < 0 )
Biskit/PDBModel.py:        a = oldN.zeros( len( indices ) )
Biskit/PDBModel.py:        oldN.put( a, negatives, length )
Biskit/PDBModel.py:        new_map = oldN.take( self.chainMap( breaks=breaks ), indices )
Biskit/PDBModel.py:        return oldN.take( new_map, index )
Biskit/PDBModel.py:        indices = self.atom2chainIndices( oldN.nonzero( atomMask), breaks=breaks )
Biskit/PDBModel.py:        r = oldN.zeros( self.lenChains(breaks=breaks) )
Biskit/PDBModel.py:        oldN.put( r, indices, 1 )
Biskit/PDBModel.py:        if max( oldN.absolute(indices) ) > self.lenChains( breaks=breaks ):
Biskit/PDBModel.py:        isArray = isinstance( p, oldN.arraytype )
Biskit/PDBModel.py:            r = oldN.array( r )
Biskit/PDBModel.py:        isArray = isinstance( p, oldN.arraytype )
Biskit/PDBModel.py:            r = oldN.take( p, self.resIndex() )
Biskit/PDBModel.py:            r = oldN.array( r )
Biskit/PDBModel.py:        self._chainIndex = oldN.concatenate( (oldI[:c1+1], oldI[c1+2:] ) ) 
Biskit/PDBModel.py:            self['serial_number'][i_scar:i_next] = oldN.arange(first, first + n)
Biskit/PDBModel.py:            anames = oldN.array( self.atoms['name'][i_start:i_scar] )
Biskit/PDBModel.py:            i_oxt = oldN.flatnonzero( oldN.logical_or( anames=='OXT', anames=='OT2' ))
Biskit/PDBModel.py:        self._resIndex = oldN.concatenate( (oldI[:r1+1], oldI[r1+2:] ) ) 
Biskit/PDBModel.py:            self['serial_number'][i_scar:i_next] = oldN.arange(first, first + n)
Biskit/PDBModel.py:            i = oldN.flatnonzero( self._chainIndex == i_scar )[0]
Biskit/PDBModel.py:                self._chainIndex = oldN.concatenate( self._chainIndex[:i],
Biskit/PDBModel.py:        r.setXyz( oldN.concatenate( ( self.getXyz(), m.getXyz() )  ) )
Biskit/PDBModel.py:        r._resIndex  = oldN.concatenate((self.resIndex(), append_I ))
Biskit/PDBModel.py:        r._chainIndex =oldN.concatenate((self.chainIndex( singleRes=1 ), append_I))
Biskit/PDBModel.py:        r.xyz = oldN.take( self.getXyz(), i )
Biskit/PDBModel.py:        r.xyzChanged = self.xyzChanged or not oldN.all(r.xyz == self.xyz)
Biskit/PDBModel.py:        new_resmap   = oldN.take( self.resMap(), i )
Biskit/PDBModel.py:        i_res     = oldN.take( new_resmap, r._resIndex )
Biskit/PDBModel.py:            new_chainmap   = oldN.take( self.chainMap(), i )
Biskit/PDBModel.py:        (in-place version of oldN.take() )
Biskit/PDBModel.py:        return self.take( oldN.nonzero( mask ), *initArgs, **initKw )
Biskit/PDBModel.py:        mask = oldN.logical_not( self.mask( what ) )
Biskit/PDBModel.py:        self.keep( oldN.nonzero(mask) )
Biskit/PDBModel.py:            chains = oldN.array( chains, int )
Biskit/PDBModel.py:            delta = oldN.concatenate( (chains[1:], [chains[-1]+1]) ) - chains
Biskit/PDBModel.py:            if not oldN.all( delta != 0 ):
Biskit/PDBModel.py:            old_chains = oldN.take( ids, self.resIndex() )
Biskit/PDBModel.py:        ri = oldN.concatenate( (self.resIndex( mask=mask ), [self.lenAtoms()] ) )
Biskit/PDBModel.py:            atoms = oldN.compress( mask, atoms ).tolist()
Biskit/PDBModel.py:            i = oldN.arange( len(ri) )
Biskit/PDBModel.py:        result = [ self.take(oldN.arange(ri[x],re[x]+1)) for x in i ]
Biskit/PDBModel.py:        if mask is None: mask = oldN.ones( self.lenAtoms() , oldN.Int )
Biskit/PDBModel.py:        return oldN.compress( mask, self.atoms['residue_number'] )
Biskit/PDBModel.py:            return oldN.array( result, oldN.Int )
Biskit/PDBModel.py:        return oldN.array(result, oldN.Int)        
Biskit/PDBModel.py:            m = oldN.compress( mask, m )
Biskit/PDBModel.py:        return oldN.concatenate( (r[1:], [self.lenAtoms()]) ) - 1 
Biskit/PDBModel.py:            return oldN.array( result, oldN.Int )
Biskit/PDBModel.py:        return oldN.array( result, oldN.Int )
Biskit/PDBModel.py:        res_names = oldN.take( self.atoms['residue_name'], chainindex )
Biskit/PDBModel.py:        res_nmbrs = oldN.take( self.atoms['residue_number'], chainindex )
Biskit/PDBModel.py:        chain_ids = oldN.take( self.atoms['chain_id'], chainindex )
Biskit/PDBModel.py:        seg_ids   = oldN.take( self.atoms['segment_id'], chainindex )
Biskit/PDBModel.py:        res_names = oldN.concatenate( (['-1'], res_names) )
Biskit/PDBModel.py:        chain_ids = oldN.concatenate( (['-1'], chain_ids) )
Biskit/PDBModel.py:        seg_ids   = oldN.concatenate( (['-1'], seg_ids ) )
Biskit/PDBModel.py:        res_nmbrs = oldN.concatenate( ([-100], res_nmbrs) )
Biskit/PDBModel.py:            delta = oldN.ones( len(delta), oldN.Int )
Biskit/PDBModel.py:        return oldN.compress( oldN.logical_not(is_single), chainindex)
Biskit/PDBModel.py:        return oldN.array( r, oldN.Int )
Biskit/PDBModel.py:        return oldN.concatenate( (r[1:], [self.lenAtoms()]) ) - 1 
Biskit/PDBModel.py:            i_bb = oldN.nonzero( self.maskBB( solvent=solvent ) )
Biskit/PDBModel.py:                last = oldN.take( bb.xyz, bb_re )[:-1]
Biskit/PDBModel.py:                first= oldN.take( bb.xyz, bb_ri )[1:]
Biskit/PDBModel.py:                dist = oldN.sqrt( oldN.sum( oldN.power(last-first,2), axis=1 ) )
Biskit/PDBModel.py:                r = oldN.nonzero( oldN.greater( dist, cutoff ) )
Biskit/PDBModel.py:        return oldN.array( r, int )
Biskit/PDBModel.py:        if not isinstance( what, list ) or isinstance( what, oldN.ndarray):
Biskit/PDBModel.py:                fx = oldN.compress( mask_fit, x, 0 )
Biskit/PDBModel.py:                fy = oldN.compress( mask_fit, y, 0 )
Biskit/PDBModel.py:            y = oldN.dot(y, oldN.transpose(r)) + t
Biskit/PDBModel.py:            x = oldN.compress( mask, x, 0 )
Biskit/PDBModel.py:            y = oldN.compress( mask, y, 0 )
Biskit/PDBModel.py:        d = oldN.sqrt(oldN.sum(oldN.power(x - y, 2), 1))
Biskit/PDBModel.py:        return oldN.sqrt( oldN.average(d**2) )
Biskit/PDBModel.py:            x = oldN.compress( mask, x, 0 )
Biskit/PDBModel.py:            y = oldN.compress( mask, y, 0 )
Biskit/PDBModel.py:            outlier_mask = oldN.zeros( oldN.sum(mask)  )
Biskit/PDBModel.py:            outlier_mask = oldN.zeros( len(self) )
Biskit/PDBModel.py:        oldN.put( outlier_mask, iter_trace[-1][-1], 1 )
Biskit/PDBModel.py:        result.setXyz( oldN.dot( self.getXyz(), oldN.transpose(r) ) + t  )
Biskit/PDBModel.py:        if mask is None: mask = oldN.ones( len(self) )
Biskit/PDBModel.py:        avg = oldN.average( oldN.compress( mask, r.getXyz(), 0 ) )
Biskit/PDBModel.py:            return oldN.average( self.getXyz() )
Biskit/PDBModel.py:        return oldN.average( oldN.compress( mask, self.getXyz(), axis=0 ) )
Biskit/PDBModel.py:        return oldN.array( M )
Biskit/PDBModel.py:        return oldN.sum( self.masses() )
Biskit/PDBModel.py:            mask = oldN.ones( len(atomValues) )
Biskit/PDBModel.py:            resAtoms = oldN.compress( oldN.equal( self.resMap(), res ), masked )
Biskit/PDBModel.py:        return oldN.array( result, oldN.Float32 )
Biskit/PDBModel.py:        equal = oldN.nonzero(seqMask)
Biskit/PDBModel.py:        equal_ref = oldN.nonzero(seqMask_ref)
Biskit/PDBModel.py:        mask_self = oldN.ones( len(self), int )
Biskit/PDBModel.py:        mask_ref  = oldN.ones( len(ref ), int )
Biskit/PDBModel.py:        oldN.put( mask_self, i, 0 )
Biskit/PDBModel.py:        oldN.put( mask_ref, iref, 0 )
Biskit/PDBModel.py:        return oldN.nonzero( mask_self ), oldN.nonzero( mask_ref )
Biskit/PDBModel.py:        rindex = oldN.concatenate( (self.resIndex(), [len(self)] ) )
Biskit/PDBModel.py:            chainMask  = oldN.equal( self._m.chainMap( breaks=1 ), c )
Biskit/PDBModel.py:        self.assertAlmostEqual( oldN.sum( m2.centerOfMass() ),  23.1032009125,2)
Biskit/PDBModel.py:        self.assert_( oldN.all( self._m2.getXyz()[0] == xyz0) )
Biskit/PDBModel.py:        self.assert_( oldN.all( oldN.array(r['chain_id']) == chain_ids ) )
Biskit/PDBModel.py:        self.assert_( oldN.all( oldN.array(r['residue_number']) == res_numbers ) )
Biskit/PDBModel.py:        self.assertEqual( type( m.getXyz() ), oldN.ndarray )
Biskit/PDBModel.py:        self.assert_( oldN.all( oldN.absolute(diff) < 1 ),
Biskit/PDBParseFile.py:                    rotation = oldN.array( rotation )
Biskit/PDBParseFile.py:                    translation = oldN.transpose( [ translation ] )
Biskit/PDBParseFile.py:                    rotation = oldN.concatenate( (rotation, translation), axis=1 )
Biskit/PDBParseFile.py:                    rtList.append(oldN.array(rotation))
Biskit/PDBParseFile.py:        return aProfs, oldN.array( xyz, oldN.Float32 ), info
Biskit/PDBParseFile.py:        self.assertAlmostEqual( oldN.sum( self.m.centerOfMass() ), 
Biskit/PDBParseModel.py:        self.assertAlmostEqual( oldN.sum( self.m.centerOfMass() ),
Biskit/PDBParsePickle.py:        self.assertAlmostEqual( oldN.sum( self.m.centerOfMass() ),
Biskit/Prosa2003.py:        result = {'prosa_pair':oldN.array(prosa_pair),
Biskit/Prosa2003.py:                  'prosa_surf':oldN.array(prosa_surf),
Biskit/Prosa2003.py:                  'prosa_tot':oldN.array(prosa_tot),
Biskit/Prosa2003.py:        return oldN.sum( r, 1 )
Biskit/Prosa2003.py:        self.assert_( oldN.sum(self.result - [ -94.568,  -64.903, -159.463 ] ) \
Biskit/Prosa.py:    return oldN.array(t[2:]).astype(oldN.Float32)
Biskit/Ramachandran.py:        self.prof = oldN.ravel(self.prof)
Biskit/Ramachandran.py:        self.gly = oldN.ravel(self.gly)
Biskit/Ramachandran.py:        self.pro = oldN.ravel(self.pro)
Biskit/Ramachandran.py:            gly_resInd  = oldN.array( m.atom2resIndices( gly_atomInd ) )
Biskit/Ramachandran.py:            pro_resInd  = oldN.array( m.atom2resIndices( pro_atomInd ) )    
Biskit/Ramachandran.py:                prof += [ oldN.average( oldN.take(aProfile, range(resIdx[i],
Biskit/Ramachandran.py:            xyz_CA =  oldN.compress( cModel.maskCA(), xyz, 0 )
Biskit/Ramachandran.py:            xyz_N  =  oldN.compress( cModel.mask( ['N'] ), xyz, 0 )
Biskit/Ramachandran.py:            xyz_C  =  oldN.compress( cModel.mask( ['C'] ), xyz, 0 )
Biskit/Ramachandran.py:        L = oldN.cross( vec21, vec32 )
Biskit/Ramachandran.py:        L_norm = oldN.sqrt(sum(L**2))
Biskit/Ramachandran.py:        R = oldN.cross( vec43, vec23 )
Biskit/Ramachandran.py:        R_norm = oldN.sqrt(sum(R**2))
Biskit/Ramachandran.py:        S     = oldN.cross( L, R )
Biskit/Ramachandran.py:        angle = oldN.arccos(angle) *180/oldN.pi
Biskit/Ramachandran.py:        x, y = oldN.shape(mat)
Biskit/Ramachandran.py:        self.psi = oldN.array( self.rama.psi )
Biskit/Ramachandran.py:        r = oldN.sum( oldN.compress( oldN.logical_not(oldN.equal(self.psi, None)),
Biskit/ReduceCoordinates.py:        self.a_indices = oldN.compress( maskH, self.a_indices )
Biskit/ReduceCoordinates.py:        nAtoms = oldN.ones(n_centers, oldN.Int) * int(len( a_indices ) / n_centers)
Biskit/ReduceCoordinates.py:        while oldN.sum(nAtoms) != len( a_indices ):
Biskit/ReduceCoordinates.py:            result += [ oldN.take( a_indices, oldN.arange(n) + pos) ]
Biskit/ReduceCoordinates.py:                bb_a_indices = oldN.compress( resModels[i].maskBB(), a_indices)
Biskit/ReduceCoordinates.py:                sc_a_indices = oldN.compress(
Biskit/ReduceCoordinates.py:                    oldN.logical_not( resModels[i].maskBB()), a_indices )
Biskit/ReduceCoordinates.py:            x = oldN.take( xyz, atom_indices, axis )
Biskit/ReduceCoordinates.py:            m = oldN.take( masses, atom_indices )
Biskit/ReduceCoordinates.py:            center = oldN.sum( x * oldN.transpose([m,]), axis=axis) / oldN.sum( m )
Biskit/ReduceCoordinates.py:                center = center[oldN.NewAxis, :]
Biskit/ReduceCoordinates.py:                center = center[:, oldN.NewAxis, :]
Biskit/ReduceCoordinates.py:                r_xyz = oldN.concatenate( (r_xyz, center), axis )
Biskit/ReduceCoordinates.py:        mProf = [ oldN.sum( oldN.take( mass, group ) ) for group in self.groups ]
Biskit/ReduceCoordinates.py:                pr = [ oldN.average( oldN.take( p0, group ) ) for group in self.groups ]
Biskit/ReduceCoordinates.py:        self.m = self.m.compress( oldN.logical_not( self.m.maskH2O() ) )
Biskit/rmsFit.py:    x_av = oldN.average(x)
Biskit/rmsFit.py:    y_av = oldN.average(y)
Biskit/rmsFit.py:    v, l, u = svd(oldN.dot(oldN.transpose(x), y))
Biskit/rmsFit.py:    r = oldN.dot(v, u)
Biskit/rmsFit.py:    t = x_av - oldN.dot(r, y_av)
Biskit/rmsFit.py:    Superimposed array y would be C{ oldN.dot(y, oldN.transpose(r)) + t }.
Biskit/rmsFit.py:    mask = oldN.ones(len(y), oldN.int32 )
Biskit/rmsFit.py:        r, t = findTransformation(oldN.compress(mask, x, 0),
Biskit/rmsFit.py:                                  oldN.compress(mask, y, 0))
Biskit/rmsFit.py:        xt = oldN.dot(y, oldN.transpose(r)) + t
Biskit/rmsFit.py:        d = oldN.sqrt(oldN.sum(oldN.power(x - xt, 2), 1)) * mask
Biskit/rmsFit.py:        rmsd = oldN.sqrt(oldN.average(oldN.compress(mask, d)**2))
Biskit/rmsFit.py:        stdv = MU.SD(oldN.compress(mask, d))
Biskit/rmsFit.py:        perc = round(float(oldN.sum(mask)) / float(len(mask)), 2)
Biskit/rmsFit.py:        mask = oldN.logical_and(mask, oldN.less(d, rmsd + z * stdv))
Biskit/rmsFit.py:        outliers = oldN.nonzero( oldN.logical_not( mask ) )
Biskit/rmsFit.py:    z = oldN.dot(y, oldN.transpose(r)) + t
Biskit/rmsFit.py:    return oldN.sqrt(oldN.sum(oldN.power(x - z, 2), 1)) 
Biskit/rmsFit.py:        r = abs( oldN.sum( oldN.ravel( rt[0] )))
Biskit/rmsFit.py:        e = abs( oldN.sum( oldN.ravel( self.EXPECT )))
Biskit/rmsFit.py:    EXPECT = oldN.array( [[ 0.9999011,   0.01311352,  0.00508244,],
Biskit/SparseArray.py:                if atype is oldN.arraytype or atype is list:
Biskit/SparseArray.py:                    self.shape = oldN.shape( a )
Biskit/SparseArray.py:        if atype is oldN.arraytype or atype is list :
Biskit/SparseArray.py:            a = oldN.array( a, self.__typecode )
Biskit/SparseArray.py:        self.indices = oldN.nonzero( oldN.logical_not( oldN.equal(a, self.__default) ) )
Biskit/SparseArray.py:        self.values = oldN.take( a, self.indices )
Biskit/SparseArray.py:        if type(a) in [ oldN.arraytype, list ]:
Biskit/SparseArray.py:            r += (oldN.array( a.nondefault() ) + len_axis_B * i ).tolist()
Biskit/SparseArray.py:            a = oldN.zeros( ( self.shape ), self.typecode() )
Biskit/SparseArray.py:            a = oldN.ones( (self.shape ), self.typecode() ) * self.default()
Biskit/SparseArray.py:        oldN.put( a, self.nondefault(), self.nondefault_values() )
Biskit/SparseArray.py:        if type( i ) in [ list, oldN.arraytype ]:
Biskit/SparseArray.py:        if type( values ) not in [ list, oldN.arraytype ]:
Biskit/SparseArray.py:        result.put( oldN.array( self.indices[pos_low : pos_high] ) - a,
Biskit/SparseArray.py:            if t_default == SparseArray and t_v == oldN.arraytype:
Biskit/SparseArray.py:        a = oldN.zeros( (6,), oldN.Float32 )
Biskit/SparseArray.py:        b = oldN.zeros( (5, 6), oldN.Float32 )
Biskit/SparseArray.py:        self.assert_( oldN.all( self.sb.toarray() == self.EXPECTED) )
Biskit/SparseArray.py:    EXPECTED = oldN.array([[ 0.,  3.,  4.,  0.,  0.,  0.],
Biskit/Statistics/Density.py:        self.val = oldN.array(val, oldN.Float32)
Biskit/Statistics/Density.py:        Z = oldN.sum(self.p) * self.delta_x
Biskit/Statistics/Density.py:        order = oldN.argsort(self.p).tolist()
Biskit/Statistics/Density.py:        cumulative = oldN.add.accumulate(oldN.take(self.p, order)) * self.delta_x
Biskit/Statistics/Density.py:        ind = oldN.nonzero(oldN.greater_equal(cumulative, 1. - level))
Biskit/Statistics/Density.py:        closest = oldN.argmin(abs(self.x - x))
Biskit/Statistics/Density.py:        ind = oldN.nonzero(oldN.greater_equal(self.p, self.p[closest])).tolist()
Biskit/Statistics/Density.py:        levels = [oldN.sum(oldN.take(self.p, i)) for i in intervals]
Biskit/Statistics/Density.py:        level = oldN.sum(levels) * self.delta_x
Biskit/Statistics/Density.py:        cum = oldN.add.accumulate(self.p) * self.delta_x
Biskit/Statistics/Density.py:        index = oldN.argmin(abs(cum - 0.5))
Biskit/Statistics/Density.py:        return self.delta_x * oldN.sum(self.p * self.x)
Biskit/Statistics/Density.py:        index = oldN.argmax(self.p)
Biskit/Statistics/Density.py:        l = oldN.array(l)
Biskit/Statistics/Density.py:        l = oldN.take(l, oldN.argsort(l))
Biskit/Statistics/Density.py:        break_points = oldN.nonzero(oldN.greater(l[1:] - l[:-1], 1))
Biskit/Statistics/Density.py:            intervals.append(tuple(oldN.take(l, range(start, index + 1))))
Biskit/Statistics/Density.py:      alpha = 1/n oldN.sum( ln(vi) )
Biskit/Statistics/Density.py:      beta = oldN.sqrt( 1/(n-1) oldN.sum( ln(vi) - alpha )^2  )
Biskit/Statistics/Density.py:        R = oldN.clip( R, clip, max( R ) )
Biskit/Statistics/Density.py:    mean = oldN.average( oldN.log( R ) )
Biskit/Statistics/Density.py:    stdv = oldN.sqrt(oldN.sum(oldN.power(oldN.log( R ) - mean, 2)) / (n - 1.))
Biskit/Statistics/Density.py:    X = [(v, p_lognormal(v, mean, stdv) ) for v in oldN.arange(start, stop, step)]
Biskit/Statistics/Density.py:                   for x in oldN.arange(0.00001, 50, 0.001)]
Biskit/Statistics/lognormal.py:    return oldN.exp(R.normal(alpha, beta, shape))
Biskit/Statistics/lognormal.py:    return oldN.exp(-0.5/beta**2 * (oldN.log(r) - alpha)**2 \
Biskit/Statistics/lognormal.py:                 - 0.5*oldN.log(2*oldN.pi)-oldN.log(beta*r))
Biskit/Statistics/lognormal.py:    r = t * oldN.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + \
Biskit/Statistics/lognormal.py:    r_max = oldN.exp(alpha - beta**2)
Biskit/Statistics/lognormal.py:    upper = (oldN.log(x) - alpha) / beta 
Biskit/Statistics/lognormal.py:    return 0.5 * (erf(upper / oldN.sqrt(2)) - erf(-(upper + 2*beta) / oldN.sqrt(2)))
Biskit/Statistics/lognormal.py:    return oldN.exp( alpha + (beta**2)/2. )
Biskit/Statistics/lognormal.py:    return logMean( alpha, beta ) * oldN.sqrt( oldN.exp(beta**2) - 1.)
Biskit/Statistics/lognormal.py:    return oldN.exp( alpha )
Biskit/Statistics/lognormal.py:        R = oldN.clip( R, clip, max( R ) )
Biskit/Statistics/lognormal.py:    R = oldN.compress( R, R )
Biskit/Statistics/lognormal.py:    alpha = oldN.average( oldN.log( R ) )
Biskit/Statistics/lognormal.py:    beta = oldN.sqrt(oldN.sum(oldN.power(oldN.log( R ) - alpha, 2)) / (n - 1.))
Biskit/Statistics/lognormal.py:            gnuplot.plot( H.density( oldN.array(cr) - ca, 100 ) )
Biskit/SurfaceRacer.py:            model.maskHeavy() * oldN.logical_not( model.maskSolvent())
Biskit/SurfaceRacer.py:        result = {'curvature':oldN.array(curv),
Biskit/SurfaceRacer.py:                  'MS':oldN.array(ms),
Biskit/SurfaceRacer.py:                  'AS':oldN.array(asa),
Biskit/SurfaceRacer.py:        mask = oldN.greater( profile, upperLimit )
Biskit/SurfaceRacer.py:        mask += oldN.less( profile, lowerLimit )
Biskit/SurfaceRacer.py:        for i in  oldN.nonzero(mask):
Biskit/SurfaceRacer.py:        self.e = ( oldN.sum(self.r['relMS'][10:20]), oldN.sum(self.r['relAS'][10:20]),
Biskit/SurfaceRacer.py:              oldN.sum(self.r['curvature'][10:20]) )
Biskit/surfaceRacerTools.py:        return  oldN.clip( oldN.array(rel), 0.0, 100.0 )
Biskit/surfaceRacerTools.py:        return  oldN.array(rel)
Biskit/surfaceRacerTools.py:        surf = oldN.ones( self.m.lenAtoms()) * 10.0
Biskit/surfaceRacerTools.py:        self.assertEqual( oldN.sum(relExp), 44276.860852223857 )
Biskit/tools.py:    if type( o ) == list or type( o ) == type( oldN.array([])):
Biskit/tools.py:        return oldN.array( map( int, o ) )
Biskit/tools.py:    return oldN.array( [ int( o ) ] )
Biskit/tools.py:    factors = oldN.array( factors )
Biskit/tools.py:    return oldN.sum( components )
Biskit/TrajCluster.py:        return oldN.array( map( oldN.ravel, t.frames ) )
Biskit/TrajCluster.py:            aMask = oldN.ones( self.traj.getRef().lenAtoms() )
Biskit/TrajCluster.py:           or self.n_clusters != n_clusters or oldN.any( self.aMask != aMask) \
Biskit/TrajCluster.py:            clst = int( oldN.average(pos) )
Biskit/TrajCluster.py:            if oldN.average( rmsLst ) > rmsLimit:
Biskit/TrajCluster.py:                    T.flushPrint('Converged at %i clusters, current average cluster rmsd %.2f\n'%( clst, oldN.average( rmsLst ) ))
Biskit/TrajCluster.py:                    T.flushPrint('Current cluster setting %i, current average cluster rmsd %.2f\n'%( clst, oldN.average( rmsLst ) ))
Biskit/TrajCluster.py:        lenAtoms = oldN.shape( self.fcCenters )[1] / 3
Biskit/TrajCluster.py:        return oldN.reshape( self.fcCenters, ( self.n_clusters, lenAtoms, 3))
Biskit/TrajCluster.py:        return oldN.argmax( self.memberships(), 1 )
Biskit/TrajCluster.py:        maxMemb = oldN.argmax( msm, 0 )
Biskit/TrajCluster.py:        r = [oldN.nonzero( oldN.equal(maxMemb, i) ) for i in range(0, self.n_clusters)]
Biskit/TrajCluster.py:            r2 = [ oldN.nonzero( oldN.greater( l, threshold) ) for l in msm ]
Biskit/TrajCluster.py:        if len(oldN.ravel(rms)) == 1:
Biskit/TrajCluster.py:            return oldN.average(rms), 0.0
Biskit/TrajCluster.py:        if len(oldN.ravel(rms)) == 0:
Biskit/TrajCluster.py:        return oldN.average( rms ), SD( rms )
Biskit/TrajCluster.py:            return  oldN.average(rms)
Biskit/Trajectory.py:        if type( self.frames ) is not oldN.ndarray:
Biskit/Trajectory.py:            self.frames = oldN.array( self.frames )
Biskit/Trajectory.py:        if type( self.resIndex ) is not oldN.ndarray:
Biskit/Trajectory.py:            self.resIndex = oldN.array( self.resIndex )
Biskit/Trajectory.py:                self.frames = oldN.array( self.frames ).astype(oldN.Float32)
Biskit/Trajectory.py:        result.setXyz( oldN.average( self.frames ) )
Biskit/Trajectory.py:                if oldN.all( atomCast == range( len( m ) ) ):
Biskit/Trajectory.py:        return oldN.array(frameList).astype(oldN.Float32)
Biskit/Trajectory.py:        r.frames = oldN.concatenate( (self.frames, traj[0].frames), 0 )
Biskit/Trajectory.py:                r.pc['p'] = oldN.concatenate( (self.pc['p'], traj[0].pc['p']),0)
Biskit/Trajectory.py:                r.pc['u'] = oldN.concatenate( (self.pc['u'], traj[0].pc['u']),0)
Biskit/Trajectory.py:        r.frames = oldN.concatenate( (self.frames, traj[0].frames), 1 )
Biskit/Trajectory.py:        return oldN.shape( self.frames )[1]
Biskit/Trajectory.py:        indices = oldN.compress( oldN.less( indices, len( self.frames) ), indices )
Biskit/Trajectory.py:        r.frames = oldN.take( self.frames, indices, 0 )
Biskit/Trajectory.py:            r.frameNames = oldN.take( self.frameNames, indices, 0 )
Biskit/Trajectory.py:        return self.takeFrames( oldN.nonzero( mask ) )
Biskit/Trajectory.py:        i.remove( oldN.array(indices) )
Biskit/Trajectory.py:        r.frames = oldN.take( self.frames, indices, 1 )
Biskit/Trajectory.py:        return self.takeAtoms( oldN.nonzero( aMask ), returnClass )
Biskit/Trajectory.py:        mask = oldN.logical_not( self.atomMask( what ) )
Biskit/Trajectory.py:        self.keepAtoms( oldN.nonzero( mask ) )
Biskit/Trajectory.py:            refxyz = oldN.average( self.frames, 0 )
Biskit/Trajectory.py:            mask = oldN.ones( len( refxyz ), oldN.int32 )
Biskit/Trajectory.py:        refxyz = oldN.compress( mask, refxyz, 0 )
Biskit/Trajectory.py:                                                 oldN.compress( mask, xyz, 0), n_it)
Biskit/Trajectory.py:                xyz_transformed = oldN.dot( xyz, oldN.transpose(r)) + t
Biskit/Trajectory.py:                                                  oldN.compress( mask, xyz, 0))
Biskit/Trajectory.py:                xyz_transformed = oldN.dot( xyz, oldN.transpose(r)) + t
Biskit/Trajectory.py:                d = oldN.sqrt(oldN.sum(oldN.power( oldN.compress(mask, xyz_transformed,0)\
Biskit/Trajectory.py:                rms += [ oldN.sqrt( oldN.average(d**2) ) ]
Biskit/Trajectory.py:                self.frames[i] = xyz_transformed.astype(oldN.float32)
Biskit/Trajectory.py:        r = oldN.transpose( r )
Biskit/Trajectory.py:        r = r.astype(oldN.Float32)
Biskit/Trajectory.py:        t = t.astype(oldN.Float32)
Biskit/Trajectory.py:            self.frames[ i ] = oldN.array( oldN.dot( self.frames[i], r ) ) + t 
Biskit/Trajectory.py:            f = oldN.ravel( self.frames[ fi ] )
Biskit/Trajectory.py:                     oldN.sum(mask)==N_items
Biskit/Trajectory.py:            frames = oldN.compress( aMask, frames, 1 )
Biskit/Trajectory.py:        result = oldN.zeros( (len( frames ), len( frames )), oldN.Float32 )
Biskit/Trajectory.py:                    d = oldN.sqrt(oldN.sum(oldN.power(frames[i]-frames[j], 2), 1))
Biskit/Trajectory.py:                    result[i,j] = result[j,i] = oldN.sqrt( oldN.average(d**2) )
Biskit/Trajectory.py:            frames = oldN.compress( mask, frames, 1 )
Biskit/Trajectory.py:        avg = oldN.average( frames )
Biskit/Trajectory.py:        return oldN.average(oldN.sqrt(oldN.sum(oldN.power(frames - avg, 2), 2) ))
Biskit/Trajectory.py:            rchainMap = oldN.take( self.chainMap(), self.resIndex() )
Biskit/Trajectory.py:        if left_allowed  is None: left_allowed = oldN.nonzero( self.ref.maskBB() )
Biskit/Trajectory.py:        if right_allowed is None: right_allowed= oldN.nonzero( self.ref.maskBB() )
Biskit/Trajectory.py:            mask = oldN.ones( len( self.frames[0] ), oldN.int32 )
Biskit/Trajectory.py:        residues = oldN.nonzero( self.ref.atom2resMask( mask ) )
Biskit/Trajectory.py:        fit_atoms_right = oldN.nonzero( self.ref.mask( right_atoms ) )
Biskit/Trajectory.py:        fit_atoms_left  = oldN.nonzero( self.ref.mask( left_atoms ) )
Biskit/Trajectory.py:        rchainMap = oldN.take( self.ref.chainMap(), self.ref.resIndex() )
Biskit/Trajectory.py:                frames = oldN.take( t_res.frames, i_center, 1 )
Biskit/Trajectory.py:                avg = oldN.average( frames )
Biskit/Trajectory.py:                rmsd = oldN.average(oldN.sqrt(oldN.sum(oldN.power(frames - avg, 2), 2) ))
Biskit/Trajectory.py:                result.extend( oldN.zeros( len(i_res), oldN.Float32 ) )
Biskit/Trajectory.py:            mask = oldN.ones( len( self.frames[0] ), oldN.int32 )
Biskit/Trajectory.py:            resAtoms = oldN.compress( oldN.equal( self.resMap(), res ), masked )
Biskit/Trajectory.py:        return oldN.array( result )
Biskit/Trajectory.py:        result = oldN.take( result, self.ref.resIndex() )
Biskit/Trajectory.py:            result['p'] = oldN.take( result['p'], indices, 0 )
Biskit/Trajectory.py:            result['u'] = oldN.take( result['u'], indices, 0 )
Biskit/Trajectory.py:                result['fMask'] = oldN.take( result['fMask'], indices, 0 )
Biskit/Trajectory.py:        return self.__takePca( oldN.nonzero( fMask ) )
Biskit/Trajectory.py:            aMask = oldN.ones( self.getRef().lenAtoms(), oldN.int32 )
Biskit/Trajectory.py:        if frameMask is None: frameMask = oldN.ones( len( self.frames ), oldN.int32 )
Biskit/Trajectory.py:        if atomMask is None: atomMask = oldN.ones(self.getRef().lenAtoms(),
Biskit/Trajectory.py:                                               oldN.int32)
Biskit/Trajectory.py:        refxyz = oldN.average( self.frames, 0 )
Biskit/Trajectory.py:        data = oldN.compress( frameMask, self.frames, 0 )
Biskit/Trajectory.py:        data = oldN.compress( atomMask, data, 1 )
Biskit/Trajectory.py:        data = oldN.array( map( oldN.ravel, data ) )
Biskit/Trajectory.py:        return U, V * L, oldN.power(L, 2)
Biskit/Trajectory.py:        x_avg = oldN.average(self.frames, 0)
Biskit/Trajectory.py:        X = oldN.array( [oldN.ravel(x) for x in self.frames - x_avg] )
Biskit/Trajectory.py:        alpha_0 = oldN.dot( X[ref], U[ev] )
Biskit/Trajectory.py:        alpha_range = oldN.dot(X, U[ev]) - alpha_0
Biskit/Trajectory.py:            alpha_range = oldN.sort( alpha_range )
Biskit/Trajectory.py:        Y = oldN.array( [ X[ref] + alpha * U[ev] for alpha in alpha_range] )
Biskit/Trajectory.py:        Y = oldN.reshape(Y, (Y.shape[0], -1, 3))
Biskit/Trajectory.py:            oldN.logical_not( self.traj.ref.maskH2O()) )
Biskit/Trajectory.py:        self.assertAlmostEqual( oldN.sum( self.traj.profile('rms') ),
Biskit/TrajFlexMaster.py:        r = int(round( n_frames * 1.0 / oldN.sqrt(n_per_node * n_nodes) ))
Biskit/TrajFlexMaster.py:        r = oldN.zeros( len(traj), oldN.Int )
Biskit/TrajFlexMaster.py:            oldN.put( r, mi, i )
Biskit/TrajFlexMaster.py:        a  = oldN.zeros( (n1,n2), oldN.Float32 )
Biskit/TrajFlexMaster.py:            window = oldN.reshape( value, (i_stop-i_start, j_stop-j_start) )
Biskit/TrajFlexMaster.py:            window = window.astype(oldN.Float32)
Biskit/TrajFlexMaster.py:            for i in range( oldN.shape(a)[0] ):
Biskit/TrajFlexMaster.py:                for j in range( i, oldN.shape(a)[1] ):
Biskit/TrajFlexMaster.py:            for i in range( oldN.shape(a)[0] ):
Biskit/TrajFlexMaster.py:                for j in range( i, oldN.shape(a)[1] ):
Biskit/TrajFlexMaster.py:        a = oldN.take( m, i1, 0 )
Biskit/TrajFlexMaster.py:        a = oldN.take( a, i2, 1 )
Biskit/TrajFlexMaster.py:            for i in range( oldN.shape(a)[0] ):
Biskit/TrajFlexMaster.py:                for j in range( i, oldN.shape(a)[1] ):
Biskit/TrajFlexMaster.py:        return oldN.average(r), mathUtils.SD(r)
Biskit/TrajFlexMaster.py:            d = oldN.zeros( oldN.shape( f ), oldN.Float32)
Biskit/TrajFlexMaster.py:                d = random( oldN.shape( f ) ) * ((i / 10) + 1) 
Biskit/TrajFlexSlave.py:            a = oldN.zeros( (i_stop-i_start, j_stop-j_start), oldN.Float )
Biskit/TrajFlexSlave.py:            return oldN.ravel(a).tolist()
Biskit/WhatIf.py:        ASA_values = oldN.array(map(lambda row: map(string.atof, row),
Biskit/WhatIf.py:        col_0 = oldN.greater( oldN.transpose(ASA_values)[0], totalCut )
Biskit/WhatIf.py:        col_1 = oldN.greater( oldN.transpose(ASA_values)[1], backboneCut )
Biskit/WhatIf.py:        col_2 = oldN.greater( oldN.transpose(ASA_values)[2], sidechainCut )
Biskit/WhatIf.py:        col_012 = oldN.concatenate( ([col_0],[col_1],[col_2]) ) 
Biskit/WhatIf.py:        exposedList = oldN.greater(oldN.sum(col_012), 0)
Biskit/WhatIf.py:                      -> oldN.array( 1 x N_atoms )
Biskit/WhatIf.py:                if not oldN.all(m_ref[k] == m[k]):
Biskit/WhatIf.py:        self.assertAlmostEqual( oldN.sum(resAcc[:,0]), 2814.6903, 7 ) 
